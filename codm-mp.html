<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CODM — Worlds MP Analyzer</title>
<meta name="theme-color" content="#0d1014"/>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>

<style>
  /* ===== Palette / base ===== */
  :root{
    --bg:#0d1014; --panel:#292d42; --panel2:#1e2432;
    --ink:#f3f6fa; --muted:#b8c0cc; --brand:#ffe93b; --brandText:#0b0d0e;
    --brand2:#ffffff; --line:#4c525d; --chip:#213830;
    --good:#62e887; --bad:#ff6b6b; --warn:#ffe93b;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif}
  a{color:var(--brand);text-decoration:none}
  a:hover{text-decoration:underline}
  header{position:sticky;top:0;z-index:20;background:linear-gradient(180deg,#141a23 0%,#0d1014 100%);border-bottom:2px solid var(--brand)}
  .head{display:flex;align-items:center;gap:14px;max-width:1240px;margin:0 auto;padding:12px 14px}
  h1{margin:0;font-size:1.1rem;letter-spacing:.4px;color:var(--brand)}
  .shell{max-width:1240px;margin:18px auto;padding:0 12px}
  .block{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:14px;margin-bottom:14px}
  .block h2{margin:0 0 8px 0;color:var(--brand2)}
  .muted{color:var(--muted)}
  .grid2{display:grid;grid-template-columns:1fr;gap:14px}
  @media(min-width:1024px){ .grid2{grid-template-columns:1fr 1fr} }
  .grid3{display:grid;grid-template-columns:1fr;gap:14px}
  @media(min-width:1024px){ .grid3{grid-template-columns:1fr 1fr 1fr} }

  /* ===== Filter bar ===== */
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .chip{background:var(--chip);border:1px solid var(--line);color:#d2efe1;border-radius:999px;padding:6px 10px}
  .controls input,.controls select{background:#151b26;color:var(--ink);border:1px solid var(--line);border-radius:8px;padding:8px 10px}
  .btn{background:var(--brand);color:#0c0e10;border:0;border-radius:10px;padding:8px 12px;font-weight:800;cursor:pointer}
  .btn.secondary{background:#1a2030;color:#d6dbe6;border:1px solid var(--line)}
  .right{ text-align:right }

  /* ===== Series card (balanced header + centered mid cell) ===== */
  .series-card{background:var(--panel2);border:1px solid var(--line);border-radius:12px;overflow:hidden}
  .series-head{
    display:grid;
    grid-template-columns:1fr auto 1fr;
    grid-template-rows:auto auto;
    gap:6px 10px;
    align-items:center;
    padding:10px 12px;
    border-bottom:1px solid var(--line);
    background:#1a2030;
  }
  .team{display:flex;align-items:center;font-weight:900}
  .team.right{justify-content:flex-end;text-align:right}
  .series-score{
    justify-self:center;
    font-weight:900;font-size:1.05rem;color:#fff;
    background:#101420;border:1px solid var(--line);
    border-radius:8px;padding:6px 10px
  }
  .series-meta{grid-column:1/-1;justify-self:center;font-size:.85rem;color:var(--muted)}

  .map-row{
    display:grid;
    grid-template-columns:1fr minmax(200px,1.4fr) 1fr;
    gap:10px;padding:10px 12px;border-top:1px solid #2f3545;align-items:center
  }
  .map-row:nth-child(odd){background:#181e2a}
  .side{display:flex;gap:8px;align-items:center}
  .side.left{justify-content:flex-start}
  .side.right{justify-content:flex-end}
  .tick,.cross{width:16px;height:16px;border-radius:50%;display:inline-block}
  .tick{background:var(--good)} .cross{background:var(--bad)}
  .dim{opacity:.5}
  .mid{display:flex;flex-direction:column;align-items:center;gap:2px;color:#fff}
  .mode-pill{font-size:.7rem;border:1px solid var(--line);padding:2px 6px;border-radius:999px;background:#111827;color:#e8ecf5}
  .map-title{font-weight:800}
  .series-foot{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-top:1px solid var(--line);background:#1a2030;color:var(--muted);font-size:.9rem}

  /* ===== Tables ===== */
  table{width:100%;border-collapse:collapse;font-size:.92rem}
  th,td{border-bottom:1px solid #40475a;padding:8px 10px;vertical-align:top}
  thead th{background:#141a1f;text-align:left;position:sticky;top:0}

  /* ===== Standings look / layout ===== */
  .standings caption{caption-side:top;text-align:left;color:var(--muted);margin-bottom:6px}
  .standings thead th{background:#203045}
  .standings tbody tr:nth-child(-n+6) td{background:#2a4a34;border-bottom:1px solid #335540}
  .standings td.right{ text-align:right }

  /* ===== Chart cards ===== */
  .card{background:var(--panel2);border:1px solid var(--line);border-radius:12px;padding:12px}
  .card h3{margin:0 0 8px 0;color:#fff;font-size:1.02rem}
  canvas{width:100%;height:280px}
</style>
</head>
<body>
<header>
  <div class="head">
    <h1>CODM — Worlds MP Analyzer</h1>
  </div>
</header>

<div class="shell">

  <!-- FILTERS -->
  <section class="block">
    <h2>Filters</h2>
    <div class="controls">
      <label class="chip">Team
        <select id="fTeam"></select>
      </label>
      <label class="chip">Opponent
        <select id="fOpp"></select>
      </label>
      <label class="chip">Mode
        <select id="fMode"></select>
      </label>
      <label class="chip">Map
        <select id="fMap"></select>
      </label>
      <label class="chip">Stage
        <select id="fStage"></select>
      </label>
      <label class="chip">Day
        <select id="fDay"></select>
      </label>
      <label class="chip">Result
        <select id="fWL">
          <option value="ALL">All</option>
          <option value="W">Win</option>
          <option value="L">Loss</option>
        </select>
      </label>
      <label class="chip">Search
        <input id="fSearch" type="text" placeholder="Team / Opponent / Map / Mode…">
      </label>
      <button class="btn" id="applyBtn">Apply</button>
      <button class="btn secondary" id="resetBtn">Reset</button>
      <button class="btn secondary" id="exportBtn">Export CSV</button>
    </div>
    <div class="muted" id="meta">—</div>
  </section>

  <!-- SERIES VIEWER + QUICK ANALYTICS -->
  <section class="block">
    <div class="grid2">
      <div>
        <h2>Series Viewer</h2>
        <div class="controls" style="margin-bottom:8px">
          <label class="chip">Pick Series
            <select id="fSeries"></select>
          </label>
          <span class="muted" id="seriesHint">—</span>
        </div>
        <div id="seriesCard" class="series-card">Loading…</div>
      </div>

      <div>
        <h2>Quick Analytics (current scope)</h2>
        <table id="quickTbl"></table>
        <div class="grid2" style="margin-top:12px">
          <div>
            <h3 style="margin:8px 0">By Mode</h3>
            <table id="modeTbl"></table>
          </div>
          <div>
            <h3 style="margin:8px 0">By Map</h3>
            <table id="mapTbl"></table>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- STANDINGS: Overall then Per-Mode (vertical stack) -->
  <section class="block">
    <h2>Standings (series-based) — Overall and Per Mode</h2>
    <table class="standings" id="standOverall"></table>
    <div id="standModesWrap"></div>
    <div class="muted" style="margin-top:6px">
      Notes: <b>Series Score</b> counts series wins (per best-of), <b>Match Win/Loss</b> come from map results.
      <b>Win %</b> is maps-based for the table shown. Rows with NULL/blank <code>W/L</code> are ignored everywhere.
    </div>
  </section>

  <!-- EXTRA ANALYTICS: Charts -->
  <section class="block">
    <h2>Visual Analytics (reacts to filters)</h2>
    <div class="grid3">
      <div class="card">
        <h3>Win Rate by Team (top 10 by games)</h3>
        <canvas id="chartTeams"></canvas>
      </div>
      <div class="card">
        <h3>Win Rate by Map (top 10 by games)</h3>
        <canvas id="chartMaps"></canvas>
      </div>
      <div class="card">
        <h3>Win Rate by Mode</h3>
        <canvas id="chartModes"></canvas>
      </div>
    </div>
  </section>

  <!-- RAW ROWS -->
  <section class="block">
    <h2>Rows</h2>
    <table id="rowsTbl"></table>
  </section>
</div>

<script>
/* ====== Supabase client ====== */
const SUPA_URL = 'https://fjdyppkanjnvyscqrfum.supabase.co';
const SUPA_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZqZHlwcGthbmpudnlzY3FyZnVtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAzNDU1NzIsImV4cCI6MjA3NTkyMTU3Mn0.ssEN7uA9BVm9AkhsjkWxhPzV1-VQVxc4-u7LS2wt4Aw';
const client = supabase.createClient(SUPA_URL, SUPA_KEY);

/* ====== Helpers & normalization ====== */
const el = id => document.getElementById(id);
const n  = v => Number(v ?? 0) || 0;
const norm= v => (v==null ? '' : String(v)).trim();
const sum = (arr, k) => arr.reduce((a,r)=>a+n(r[k]),0);
const groupBy = (arr, keyFn) => arr.reduce((m,r)=>{ const k = keyFn(r); (m[k]=m[k]||[]).push(r); return m; },{});
const distinct = (rows,key) => Array.from(new Set(rows.map(r=>r[key]).filter(Boolean)));
const matchIdx = r => n(r.MATCHES) || n(r.Match) || n(r.Game) || n(r.MapNo) || 0;
const hasResult = r => { const wl = norm(r['W/L']).toUpperCase(); return wl==='W' || wl==='L'; };

const MODE_ORDER = ['Hardpoint','Search & Destroy','Control'];
const modeRank = m => { const i = MODE_ORDER.indexOf(m); return i<0 ? 99 : i; };

function canonMode(m){
  const s = norm(m).toLowerCase();
  if (!s) return '';
  if (s.includes('hard')) return 'Hardpoint';          // covers Hardpoint2
  if (s.includes('search') || s.includes('snd')) return 'Search & Destroy';
  if (s.includes('control')) return 'Control';
  return m; // fallback as-is
}

function toCSV(rows){
  if(!rows.length) return '';
  const cols = Object.keys(rows[0]);
  const head = cols.join(',');
  const body = rows.map(r => cols.map(c=>{
    const s = r[c]==null ? '' : String(r[c]);
    return /(,|\n|\"|\r)/.test(s) ? '"'+s.replace(/"/g,'""')+'"' : s;
  }).join(',')).join('\n');
  return head+'\n'+body;
}
function download(name, text){
  const blob = new Blob([text], {type:'text/csv;charset=utf-8;'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob); a.download = name; a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href), 2000);
}

/* ====== Canonical series key (dedupe A/B order) ====== */
function seriesKeyCanonical(stage, day, series, tag, opp){
  const A = norm(tag), B = norm(opp);
  const [t1,t2] = A.localeCompare(B) <= 0 ? [A,B] : [B,A];
  return `${norm(stage)}|${norm(day)}|${norm(series)}|${t1}|${t2}`;
}
function parseSeriesKey(key){
  const [stage, day, series, A, B] = key.split('|');
  return {stage, day, series, A, B};
}

/* ====== Build Series dropdown (deduped, ignore null W/L) ====== */
function setSeriesOptions(rows){
  const dd = el('fSeries');

  const valid = rows.filter(hasResult);
  const map = new Map(); // key -> {label, ord}
  valid.forEach(r=>{
    const key = seriesKeyCanonical(r.Stage, r.Day, r.Series, r.Tag, r['Vs Opponent']);
    if (!map.has(key)){
      const label = `${norm(r.Tag)} vs ${norm(r['Vs Opponent'])} • ${norm(r.Stage)||'—'} D${norm(r.Day)||'—'} • Series ${norm(r.Series)||'—'}`;
      const ord = [norm(r.Stage), n(r.Day), n(r.Series), matchIdx(r), n(r.id)];
      map.set(key, {key, label, ord});
    }
  });

  const items = Array.from(map.values()).sort((a,b)=>{
    const A=a.ord, B=b.ord;
    return (String(A[0]).localeCompare(String(B[0])) || A[1]-B[1] || A[2]-B[2] || A[3]-B[3] || A[4]-B[4]);
  });

  const prev = dd.value;
  dd.innerHTML = items.map(s=>`<option value="${s.key}">${s.label}</option>`).join('');
  dd.value = items.find(s=>s.key===prev)?.key || (items[items.length-1]?.key || '');
  el('seriesHint').textContent = `${items.length} series in scope`;

  if (!items.length){
    el('seriesCard').innerHTML = '<div class="muted" style="padding:12px">No series in scope — widen your filters.</div>';
  }
}

/* ====== State ====== */
let ALL = [];
let SCOPE = [];

/* ====== Fetch (with pagination) ====== */
async function fetchAll(){
  const step = 1000;
  let from = 0;
  const out = [];
  for(;;){
    const { data, error } = await client
      .from('mp_data')
      .select('*')
      .order('id', { ascending: true })
      .range(from, from + step - 1);

    if (error){ console.error(error); alert('Failed to load mp_data: '+error.message); break; }
    const rows = data || [];
    out.push(...rows);
    if (rows.length < step) break;
    from += rows.length;
  }
  return out;
}

/* ====== Filters ====== */
function setOptions(sel, values, labelAll='All'){
  const prev = sel.value || 'ALL';
  sel.innerHTML = `<option value="ALL">${labelAll}</option>` +
    values.sort((a,b)=> modeRank(a)-modeRank(b) || String(a).localeCompare(String(b),undefined,{numeric:true}))
          .map(v=>`<option value="${v}">${v}</option>`).join('');
  sel.value = (prev && (prev==='ALL' || values.includes(prev))) ? prev : 'ALL';
}
function populateDropdowns(){
  setOptions(el('fTeam'),  distinct(ALL,'Tag'),  'All teams');
  setOptions(el('fOpp'),   distinct(ALL,'Vs Opponent'), 'All opponents');
  const modes = Array.from(new Set(ALL.map(r=>r.ModeC).filter(Boolean))).sort((a,b)=> modeRank(a)-modeRank(b));
  setOptions(el('fMode'),  modes, 'All modes');
  setOptions(el('fMap'),   distinct(ALL,'Map'),  'All maps');
  setOptions(el('fStage'), distinct(ALL,'Stage'),'All stages');
  setOptions(el('fDay'),   distinct(ALL,'Day'),  'All days');
}

function applyFilters(){
  const F = {
    team: el('fTeam').value,
    opp:  el('fOpp').value,
    mode: el('fMode').value,
    map:  el('fMap').value,
    stage:el('fStage').value,
    day:  el('fDay').value,
    wl:   el('fWL').value,
    q:    (el('fSearch').value||'').trim().toLowerCase()
  };
  let rows = ALL;
  if (F.team!=='ALL') rows = rows.filter(r=>norm(r.Tag)===norm(F.team));
  if (F.opp!=='ALL')  rows = rows.filter(r=>norm(r['Vs Opponent'])===norm(F.opp));
  if (F.mode!=='ALL') rows = rows.filter(r=>norm(r.ModeC)===norm(F.mode));
  if (F.map!=='ALL')  rows = rows.filter(r=>norm(r.Map)===norm(F.map));
  if (F.stage!=='ALL')rows = rows.filter(r=>norm(r.Stage)===norm(F.stage));
  if (F.day!=='ALL')  rows = rows.filter(r=>String(r.Day)===String(F.day));
  if (F.wl!=='ALL')   rows = rows.filter(r=>String(r['W/L']).toUpperCase()===F.wl);
  if (F.q){
    rows = rows.filter(r=>{
      const hay = [r.Tag, r['Vs Opponent'], r.Map, r.ModeC, r.Stage, r.Series].map(x=>norm(x).toLowerCase()).join('|');
      return hay.includes(F.q);
    });
  }
  SCOPE = rows;

  el('meta').textContent =
    `Rows: ${SCOPE.length} / ${ALL.length} • Teams: ${distinct(SCOPE,'Tag').length} • Opponents: ${distinct(SCOPE,'Vs Opponent').length}`;

  setSeriesOptions(SCOPE); // update series picker
}

/* ====== Analytics (ignore NULL/blank W/L) ====== */
function quickStats(rows){
  const R = rows.filter(hasResult);
  const games = R.length;
  const w = R.filter(r=>String(r['W/L']).toUpperCase()==='W').length;
  const l = R.filter(r=>String(r['W/L']).toUpperCase()==='L').length;
  const ptsFor = sum(R,'Score');
  const ptsAg  = sum(R,'Opp Score');
  return { games, wins:w, losses:l, winrate: games ? (w/games) : 0, ptsFor, ptsAg, diff: ptsFor-ptsAg };
}
function byMode(rows){
  const R = rows.filter(hasResult);
  const g = groupBy(R, r=>r.ModeC || '—');
  return Object.entries(g).map(([mode,list])=>{
    const qs = quickStats(list);
    return { mode, games:qs.games, wins:qs.wins, losses:qs.losses, winrate:qs.winrate };
  }).sort((a,b)=> modeRank(a.mode)-modeRank(b.mode));
}
function byMap(rows){
  const R = rows.filter(hasResult);
  const g = groupBy(R, r=>norm(r.Map)||'—');
  return Object.entries(g).map(([map,list])=>{
    const qs = quickStats(list);
    return { map, games:qs.games, wins:qs.wins, losses:qs.losses, winrate:qs.winrate };
  }).sort((a,b)=> b.games-a.games || b.winrate-a.winrate);
}

/* ====== Standings helpers ====== */
function seriesKeysFromScope(){
  const valid = SCOPE.filter(hasResult);
  const set = new Set();
  valid.forEach(r=>{
    set.add(seriesKeyCanonical(r.Stage, r.Day, r.Series, r.Tag, r['Vs Opponent']));
  });
  return set;
}
function seriesOutcomesByTeam(seriesKeys){
  const W = {}, L = {};
  for (const key of seriesKeys){
    const {stage, day, series, A, B} = parseSeriesKey(key);
    let rows = ALL.filter(r => norm(r.Stage)===stage && norm(r.Day)===day && norm(r.Series)===series &&
                               norm(r.Tag)===A && norm(r['Vs Opponent'])===B && hasResult(r));
    let team = A;
    if (!rows.length){
      rows = ALL.filter(r => norm(r.Stage)===stage && norm(r.Day)===day && norm(r.Series)===series &&
                             norm(r.Tag)===B && norm(r['Vs Opponent'])===A && hasResult(r));
      team = B;
    }
    if (!rows.length) continue;
    const w = rows.filter(r=>String(r['W/L']).toUpperCase()==='W').length;
    const l = rows.filter(r=>String(r['W/L']).toUpperCase()==='L').length;
    if (w>l) (W[team]=(W[team]||0)+1);
    else     (L[team]=(L[team]||0)+1);
  }
  return {W,L};
}
function buildStandingsRows(rowsForMaps, seriesKeys){
  const {W:seriesW, L:seriesL} = seriesOutcomesByTeam(seriesKeys);
  const teamsSet = new Set([...rowsForMaps.map(r=>norm(r.Tag)), ...Object.keys(seriesW), ...Object.keys(seriesL)]);
  const mapW = {}, mapL = {};
  rowsForMaps.filter(hasResult).forEach(r=>{
    const t = norm(r.Tag);
    if (String(r['W/L']).toUpperCase()==='W') mapW[t]=(mapW[t]||0)+1;
    else mapL[t]=(mapL[t]||0)+1;
  });

  const rows = [...teamsSet].map(team=>{
    const sw = seriesW[team]||0, sl = seriesL[team]||0;
    const mw = mapW[team]||0, ml = mapL[team]||0;
    const mp = mw+ml;
    return {
      team,
      series_score: sw,
      match_wins: mw,
      match_losses: ml,
      winrate: mp ? mw/mp : 0,
      played: sw + sl
    };
  }).sort((a,b)=> b.series_score-a.series_score || b.winrate-a.winrate || b.match_wins-a.match_wins || a.match_losses-b.match_losses || a.team.localeCompare(b.team));
  return rows;
}
function renderStandings(){
  const keys = seriesKeysFromScope();
  const hostOverall = el('standOverall');
  const wrap = el('standModesWrap');

  if (!keys.size){
    hostOverall.innerHTML = '<div class="muted">No series in scope.</div>';
    wrap.innerHTML = '';
    return;
  }
  const allMaps = ALL.filter(r => keys.has(seriesKeyCanonical(r.Stage, r.Day, r.Series, r.Tag, r['Vs Opponent'])));
  const overall = buildStandingsRows(allMaps, keys);
  const cols = [
    {label:'Teams',key:'team'},
    {label:'Series Score',key:'series_score',right:true},
    {label:'Match Win',key:'match_wins',right:true},
    {label:'Match Loss',key:'match_losses',right:true},
    {label:'Win %',key:'winrate',format:'pct',right:true},
    {label:'Played',key:'played',right:true},
  ];
  // Overall table (top)
  hostOverall.innerHTML =
    `<caption>Overall (all modes)</caption>
     <thead><tr>${cols.map(c=>`<th class="${c.right?'right':''}">${c.label}</th>`).join('')}</tr></thead>
     <tbody>${overall.map(r=>`<tr>${cols.map(c=>`<td class="${c.right?'right':''}">${c.format==='pct'? (r[c.key]*100).toFixed(1)+'%' : r[c.key]}</td>`).join('')}</tr>`).join('')}</tbody>`;

  // Per-mode tables stacked below, fixed order
  const modesOrdered = MODE_ORDER.filter(m => allMaps.some(r=>r.ModeC===m));
  wrap.innerHTML = modesOrdered.map(mode=>{
    const rows = buildStandingsRows(allMaps.filter(r=>r.ModeC===mode), keys);
    return `
      <table class="standings" style="margin-top:12px">
        <caption>${mode}</caption>
        <thead><tr>${cols.map(c=>`<th class="${c.right?'right':''}">${c.label}</th>`).join('')}</tr></thead>
        <tbody>${rows.map(r=>`<tr>${cols.map(c=>`<td class="${c.right?'right':''}">${c.format==='pct'? (r[c.key]*100).toFixed(1)+'%' : r[c.key]}</td>`).join('')}</tr>`).join('')}</tbody>
      </table>`;
  }).join('');
}

/* ====== Series viewer ====== */
function renderSeriesCard(key){
  if (!key){
    el('seriesCard').innerHTML = '<div class="muted" style="padding:12px">No series selected.</div>'; return;
  }
  const {stage, day, series, A, B} = parseSeriesKey(key);

  let rows = ALL.filter(r => norm(r.Stage)===stage && norm(r.Day)===day && norm(r.Series)===series &&
                              norm(r.Tag)===A && norm(r['Vs Opponent'])===B && hasResult(r))
                .sort((a,b)=> matchIdx(a) - matchIdx(b) || n(a.id)-n(b.id));
  let left=A, right=B;
  if (!rows.length){
    rows = ALL.filter(r => norm(r.Stage)===stage && norm(r.Day)===day && norm(r.Series)===series &&
                            norm(r.Tag)===B && norm(r['Vs Opponent'])===A && hasResult(r))
              .sort((a,b)=> matchIdx(a) - matchIdx(b) || n(a.id)-n(b.id));
    left=B; right=A;
  }
  if (!rows.length){ el('seriesCard').innerHTML = '<div class="muted" style="padding:12px">Series not found.</div>'; return; }

  const wins = rows.filter(r=>String(r['W/L']).toUpperCase()==='W').length;
  const losses = rows.filter(r=>String(r['W/L']).toUpperCase()==='L').length;

  const head = `
    <div class="series-head">
      <div class="team left">${left}</div>
      <div class="series-score">${wins} : ${losses} <span class="muted" style="font-weight:600"> (Bo${rows.length})</span></div>
      <div class="team right">${right}</div>
      <div class="series-meta">${stage || '—'} • Day ${day || '—'} • Series ${series || '—'}</div>
    </div>`;

  const body = rows.map(r=>{
    const youWin = String(r['W/L']).toUpperCase()==='W';
    const left  = `<div class="side left ${youWin?'':'dim'}"><span class="${youWin?'tick':'cross'}"></span><b>${n(r.Score)}</b></div>`;
    const mid   = `<div class="mid"><span class="mode-pill">${r.ModeC || '—'}</span><div class="map-title">${norm(r.Map)||'—'}</div></div>`;
    const right = `<div class="side right ${youWin?'dim':''}"><b>${n(r['Opp Score'])}</b><span class="${youWin?'cross':'tick'}"></span></div>`;
    return `<div class="map-row">${left}${mid}${right}</div>`;
  }).join('');

  const foot = `<div class="series-foot"><span>Maps played: ${rows.length}</span><span>Pick a different series from the dropdown above.</span></div>`;
  el('seriesCard').innerHTML = head + body + foot;
}

/* ====== Rows viewer (ignores blank/NULL W/L) ====== */
function renderRows(){
  const rows = SCOPE.filter(hasResult);
  const cols = [
    {label:'ID',key:'id'}, {label:'Team',key:'Tag'}, {label:'Opponent',key:'Vs Opponent'},
    {label:'Stage',key:'Stage'}, {label:'Day',key:'Day'}, {label:'Series',key:'Series'},
    {label:'Mode',key:'ModeC'}, {label:'Map',key:'Map'}, {label:'W/L',key:'W/L'},
    {label:'Score',key:'Score',right:true}, {label:'Opp',key:'Opp Score',right:true},
  ];
  const host = el('rowsTbl');
  if (!rows.length){ host.innerHTML = `<div class="muted">No rows in scope.</div>`; return; }
  const thead = `<thead><tr>${cols.map(c=>`<th class="${c.right?'right':''}">${c.label}</th>`).join('')}</tr></thead>`;
  const tbody = `<tbody>${rows.map(r=>`<tr>${cols.map(c=>{
    let v = r[c.key];
    return `<td class="${c.right?'right':''}">${v ?? '—'}</td>`;
  }).join('')}</tr>`).join('')}</tbody>`;
  host.innerHTML = `<table>${thead}${tbody}</table>`;
}

/* ====== Charts ====== */
let CHARTS = {teams:null, maps:null, modes:null};
function destroyCharts(){
  Object.values(CHARTS).forEach(c=>{ try{ c?.destroy(); }catch(_){}}); 
  CHARTS = {teams:null, maps:null, modes:null};
}
function renderCharts(){
  destroyCharts();
  const rows = SCOPE.filter(hasResult);

  // Team winrates (top 10 by games)
  const byTeam = Object.entries(groupBy(rows, r=>norm(r.Tag)))
    .map(([team,list])=>({ team, ...quickStats(list) }))
    .sort((a,b)=> b.games-a.games || b.winrate-a.winrate)
    .slice(0,10);
  const tctx = el('chartTeams').getContext('2d');
  CHARTS.teams = new Chart(tctx, {
    type:'bar',
    data:{ labels: byTeam.map(r=>r.team),
           datasets:[{ label:'Win %', data: byTeam.map(r=> (r.winrate*100).toFixed(1)) }] },
    options:{ responsive:true, maintainAspectRatio:false, indexAxis:'y',
      scales:{ x:{ ticks:{ callback:v=>v+'%' }, min:0, max:100 } } }
  });

  // Map winrates (top 10 by games)
  const byM = byMap(rows).slice(0,10);
  const mctx = el('chartMaps').getContext('2d');
  CHARTS.maps = new Chart(mctx, {
    type:'bar',
    data:{ labels: byM.map(r=>r.map),
           datasets:[{ label:'Win %', data: byM.map(r=> (r.winrate*100).toFixed(1)) }] },
    options:{ responsive:true, maintainAspectRatio:false,
      scales:{ y:{ beginAtZero:true, ticks:{ callback:v=>v+'%' }, max:100 } } }
  });

  // Mode winrates (ordered)
  const byMd = MODE_ORDER.map(m=>{
    const list = rows.filter(r=>r.ModeC===m);
    const q = quickStats(list);
    return {mode:m, winrate:q.winrate};
  }).filter(x=>rows.some(r=>r.ModeC===x.mode));
  const modectx = el('chartModes').getContext('2d');
  CHARTS.modes = new Chart(modectx, {
    type:'bar',
    data:{ labels: byMd.map(r=>r.mode),
           datasets:[{ label:'Win %', data: byMd.map(r=> (r.winrate*100).toFixed(1)) }] },
    options:{ responsive:true, maintainAspectRatio:false,
      scales:{ y:{ beginAtZero:true, ticks:{ callback:v=>v+'%' }, max:100 } } }
  });
}

/* ====== Wire up ====== */
el('applyBtn').onclick = ()=>{ applyFilters(); renderAll(); };
el('resetBtn').onclick = ()=>{
  ['fTeam','fOpp','fMode','fMap','fStage','fDay','fWL'].forEach(id=> el(id).value='ALL');
  el('fSearch').value = '';
  applyFilters(); renderAll();
};
el('exportBtn').onclick = ()=>{ const csv = toCSV(SCOPE); download('codm_mp_scope.csv', csv); };
el('fSeries').addEventListener('change', (e)=> renderSeriesCard(e.target.value));

/* ====== Main render ====== */
function renderAll(){
  // Quick stats
  const q = quickStats(SCOPE);
  (function renderQuick(){
    const host = el('quickTbl');
    const cols = [
      {label:'Games',key:'games',right:true},
      {label:'Wins',key:'wins',right:true},
      {label:'Losses',key:'losses',right
