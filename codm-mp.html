<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CODM — Worlds MP Analyzer</title>
<meta name="theme-color" content="#0d1014"/>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<style>
  /* ===== Palette / base ===== */
  :root{
    --bg:#0d1014; --panel:#292d42; --panel2:#1e2432;
    --ink:#f3f6fa; --muted:#b8c0cc; --brand:#ffe93b; --brandText:#0b0d0e;
    --brand2:#ffffff; --line:#4c525d; --chip:#213830;
    --good:#62e887; --bad:#ff6b6b; --warn:#ffe93b;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif}
  a{color:var(--brand);text-decoration:none}
  a:hover{text-decoration:underline}
  header{position:sticky;top:0;z-index:20;background:linear-gradient(180deg,#141a23 0%,#0d1014 100%);border-bottom:2px solid var(--brand)}
  .head{display:flex;align-items:center;gap:14px;max-width:1240px;margin:0 auto;padding:12px 14px}
  h1{margin:0;font-size:1.1rem;letter-spacing:.4px;color:var(--brand)}
  .shell{max-width:1240px;margin:18px auto;padding:0 12px}
  .block{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:14px;margin-bottom:14px}
  .block h2{margin:0 0 8px 0;color:var(--brand2)}
  .muted{color:var(--muted)}
  .grid2{display:grid;grid-template-columns:1fr;gap:14px}
  @media(min-width:1100px){ .grid2{grid-template-columns:1fr 1fr} }

  /* ===== Compact tables ===== */
  .compact table{width:100%;border-collapse:collapse;font-size:.84rem;line-height:1.15}
  .compact thead th{background:#141a1f;position:sticky;top:0;z-index:1}
  .compact th,.compact td{border-bottom:1px solid #3a4255;padding:6px 8px;vertical-align:middle}
  .right{text-align:right}
  .bar{background:#101621;border:1px solid var(--line);height:10px;border-radius:10px;overflow:hidden}
  .bar > span{display:block;height:100%;background:var(--brand)}

  /* ===== Filter bar ===== */
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .chip{background:var(--chip);border:1px solid var(--line);color:#d2efe1;border-radius:999px;padding:6px 10px}
  .controls input,.controls select{background:#151b26;color:var(--ink);border:1px solid var(--line);border-radius:8px;padding:6px 8px;font-size:.9rem}
  .btn{background:var(--brand);color:#0c0e10;border:0;border-radius:10px;padding:8px 12px;font-weight:800;cursor:pointer}
  .btn.secondary{background:#1a2030;color:#d6dbe6;border:1px solid var(--line)}

  /* ===== Series card (balanced two sides; mode above map) ===== */
  .series-card{background:var(--panel2);border:1px solid var(--line);border-radius:12px;overflow:hidden}
  .series-head{
    display:grid;grid-template-columns:1fr max-content 1fr;gap:8px;align-items:center;
    padding:10px 12px;border-bottom:1px solid var(--line);background:#1a2030
  }
  .team-name{font-weight:900;justify-self:start}
  .opp-name{font-weight:900;justify-self:end}
  .series-score{justify-self:center;font-weight:900;font-size:1.05rem;color:#fff;background:#101420;border:1px solid var(--line);border-radius:8px;padding:6px 10px}
  .series-meta{grid-column:1 / -1; font-size:.85rem;color:var(--muted)}

  /* perfectly symmetric lanes */
  .map-row{
    display:grid;grid-template-columns:220px 1fr 220px;gap:10px;
    padding:8px 12px;border-top:1px solid #2f3545;align-items:center
  }
  @media(max-width:700px){ .map-row{grid-template-columns:160px 1fr 160px} }
  .map-row:nth-child(odd){background:#181e2a}

  /* left/right score lanes use grid so dot & numbers always align */
  .side{display:grid;gap:8px;align-items:center}
  .side-left{grid-template-columns:16px 1fr;justify-self:start}
  .side-right{grid-template-columns:1fr 16px;justify-self:end}
  .scoreL{font-weight:800;text-align:right}
  .scoreR{font-weight:800;text-align:left}
  .tick,.cross{width:14px;height:14px;border-radius:50%}
  .tick{background:var(--good)}
  .cross{background:var(--bad)}
  .dim{opacity:.55}

  .mode-stack{display:flex;flex-direction:column;line-height:1.15}
  .mode-pill{font-size:.7rem;border:1px solid var(--line);padding:1px 6px;border-radius:999px;background:#111827;color:#e8ecf5;width:max-content}
  .map-title{font-size:.95rem;margin-top:2px}
  .series-foot{display:flex;justify-content:space-between;align-items:center;padding:8px 12px;border-top:1px solid var(--line);background:#1a2030;color:var(--muted);font-size:.85rem}

  h3{margin:8px 0;color:#fff;font-size:1rem}
</style>
</head>
<body>
<header>
  <div class="head">
    <h1>CODM — Worlds MP Analyzer</h1>
  </div>
</header>

<div class="shell">

  <!-- FILTERS -->
  <section class="block">
    <h2>Filters</h2>
    <div class="controls">
      <label class="chip">Team
        <select id="fTeam"></select>
      </label>
      <label class="chip">Opponent
        <select id="fOpp"></select>
      </label>
      <label class="chip">Mode
        <select id="fMode"></select>
      </label>
      <label class="chip">Map
        <select id="fMap"></select>
      </label>
      <label class="chip">Stage
        <select id="fStage"></select>
      </label>
      <label class="chip">Day
        <select id="fDay"></select>
      </label>
      <label class="chip">Result
        <select id="fWL">
          <option value="ALL">All</option>
          <option value="W">Win</option>
          <option value="L">Loss</option>
        </select>
      </label>
      <label class="chip">Search
        <input id="fSearch" type="text" placeholder="Team / Opponent / Map / Mode…">
      </label>
      <button class="btn" id="applyBtn">Apply</button>
      <button class="btn secondary" id="resetBtn">Reset</button>
      <button class="btn secondary" id="exportBtn">Export CSV</button>
    </div>
    <div class="muted" id="meta">—</div>
  </section>

  <!-- SERIES VIEWER + QUICK ANALYTICS -->
  <section class="block">
    <div class="grid2">
      <div>
        <h2>Series Viewer</h2>
        <div class="controls" style="margin-bottom:8px">
          <label class="chip">Pick Series
            <select id="fSeries"></select>
          </label>
          <span class="muted" id="seriesHint">—</span>
        </div>
        <div id="seriesCard" class="series-card">Loading…</div>
      </div>

      <div class="compact">
        <h2>Quick Analytics (current scope)</h2>
        <div id="quickTbl"></div>
        <div class="grid2" style="margin-top:10px">
          <div>
            <h3>By Mode</h3>
            <div id="modeTbl"></div>
          </div>
          <div>
            <h3>By Map</h3>
            <div id="mapTbl"></div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- STANDINGS -->
  <section class="block compact">
    <h2>Standings (series-based) — Overall and Per Mode</h2>
    <div id="standOverall"></div>
    <div id="standModes"></div>
  </section>

  <!-- EXTRA INSIGHTS -->
  <section class="block compact">
    <h2>More Insights</h2>
    <div class="grid2">
      <div>
        <h3>Best Teams (maps) — min 5 maps</h3>
        <div id="bestTeamsTbl"></div>
      </div>
      <div>
        <h3>Opponents faced (maps)</h3>
        <div id="oppTbl"></div>
      </div>
    </div>
    <div style="margin-top:10px">
      <h3>Mode × Map Winrate Matrix</h3>
      <div id="matrixTbl"></div>
    </div>
  </section>

  <!-- RAW ROWS -->
  <section class="block compact">
    <h2>Rows</h2>
    <div id="rowsTbl"></div>
  </section>
</div>

<script>
/* ====== Supabase client ====== */
const SUPA_URL = 'https://fjdyppkanjnvyscqrfum.supabase.co';
const SUPA_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZqZHlwcGthbmpudnlzY3FyZnVtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAzNDU1NzIsImV4cCI6MjA3NTkyMTU3Mn0.ssEN7uA9BVm9AkhsjkWxhPzV1-VQVxc4-u7LS2wt4Aw';
const client = supabase.createClient(SUPA_URL, SUPA_KEY);

/* ===== Helpers ===== */
const el = id => document.getElementById(id);
const n  = v => Number(v ?? 0) || 0;
const norm= v => (v==null ? '' : String(v)).trim();
const sum = (arr, k) => arr.reduce((a,r)=>a+n(r[k]),0);
const groupBy = (arr, keyFn) => arr.reduce((m,r)=>{ const k = keyFn(r); (m[k]=m[k]||[]).push(r); return m; },{});
const distinct = (rows,key) => Array.from(new Set(rows.map(r=>r[key]).filter(Boolean)));
const pctStr = (a,b) => b ? (a/b*100).toFixed(1)+'%' : '—';
const cleanWL = v => { const s = norm(v).toUpperCase(); return s==='W' || s==='L' ? s : ''; };

/* Mode normalization and ordering */
const MODE_ORDER = ['Hardpoint','Search & Destroy','Control'];
function normalizeMode(m){
  const s = norm(m).toLowerCase();
  if (!s) return '';
  if (s.includes('hardpoint')) return 'Hardpoint';
  if (s.includes('search') || s.includes('snd')) return 'Search & Destroy';
  if (s.includes('control')) return 'Control';
  return norm(m);
}

/* CSV */
function toCSV(rows){
  if(!rows.length) return '';
  const cols = Object.keys(rows[0]);
  const head = cols.join(',');
  const body = rows.map(r => cols.map(c=>{
    const s = r[c]==null ? '' : String(r[c]);
    return /(,|\n|\"|\r)/.test(s) ? '"'+s.replace(/"/g,'""')+'"' : s;
  }).join(',')).join('\n');
  return head+'\n'+body;
}
function download(name, text){
  const blob = new Blob([text], {type:'text/csv;charset=utf-8;'}); const a = document.createElement('a');
  a.href = URL.createObjectURL(blob); a.download = name; a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href), 1500);
}

/* ===== Data state ===== */
let ALL = [];   // all rows (normalized)
let SCOPE = []; // rows post-filters (W/L present)

/* ===== Fetch (paginated) ===== */
async function fetchAll(){
  const step = 1000;
  let from = 0;
  const out = [];
  for(;;){
    const { data, error } = await client
      .from('mp_data')
      .select('*')
      .order('id', { ascending: true })
      .range(from, from + step - 1);
    if (error){ console.error(error); alert('Failed to load mp_data: '+error.message); break; }
    const rows = data || [];
    out.push(...rows);
    if (rows.length < step) break;
    from += rows.length;
  }
  return out;
}

/* ===== Filters ===== */
function setOptions(sel, values, labelAll='All'){
  const prev = sel.value || 'ALL';
  sel.innerHTML = `<option value="ALL">${labelAll}</option>` +
    values.sort((a,b)=>String(a).localeCompare(String(b),undefined,{numeric:true}))
          .map(v=>`<option value="${v}">${v}</option>`).join('');
  sel.value = (prev && (prev==='ALL' || values.includes(prev))) ? prev : 'ALL';
}
function populateDropdowns(){
  setOptions(el('fTeam'),  distinct(ALL,'Tag'),  'All teams');
  setOptions(el('fOpp'),   distinct(ALL,'Vs Opponent'), 'All opponents');
  setOptions(el('fMode'),  Array.from(new Set(ALL.map(r=>r.ModeN).filter(Boolean))), 'All modes');
  setOptions(el('fMap'),   distinct(ALL,'Map'),  'All maps');
  setOptions(el('fStage'), distinct(ALL,'Stage'),'All stages');
  setOptions(el('fDay'),   distinct(ALL,'Day'),  'All days');
}

/* Neutral series key (dedup; team-agnostic) */
function seriesKeyNeutral(r){
  const stage = norm(r.Stage), day = norm(r.Day), ser = norm(r.Series);
  const a = norm(r.Tag), b = norm(r['Vs Opponent']);
  const pair = [a,b].sort((x,y)=>x.localeCompare(y)).join('~');
  return `${stage}|${day}|${ser}|${pair}`;
}

/* Build series dropdown from SCOPE */
function setSeriesOptions(rows){
  const dd = el('fSeries');
  const items = [...new Map(rows.map(r=>{
    const key = seriesKeyNeutral(r);
    const [stage,day,ser,pair] = key.split('|');
    const [t1,t2] = pair.split('~');
    const label = `${t1} vs ${t2} • ${stage||'—'} • Day ${day||'—'} • Series ${ser||'—'}`;
    const ord = [stage, Number(day)||0, Number(ser)||0, Number(r.MATCHES)||0, Number(r.id)||0];
    return [key, {key,label,ord}];
  })).values()]
  .sort((a,b)=> String(a.ord[0]).localeCompare(String(b.ord[0])) || a.ord[1]-b.ord[1] || a.ord[2]-b.ord[2] || a.ord[3]-b.ord[3] || a.ord[4]-b.ord[4]);

  const prev = dd.value;
  dd.innerHTML = items.map(s=>`<option value="${s.key}">${s.label}</option>`).join('');
  dd.value = items.find(s=>s.key===prev)?.key || (items[items.length-1]?.key || '');
  el('seriesHint').textContent = `${items.length} series in scope`;

  if (!items.length){
    el('seriesCard').innerHTML = '<div class="muted" style="padding:12px">No series in scope — widen your filters.</div>';
  }
}

/* Apply filters (ignore blank/NULL W/L in scope) */
function applyFilters(){
  const F = {
    team: el('fTeam').value,
    opp:  el('fOpp').value,
    mode: el('fMode').value,
    map:  el('fMap').value,
    stage:el('fStage').value,
    day:  el('fDay').value,
    wl:   el('fWL').value,
    q:    (el('fSearch').value||'').trim().toLowerCase()
  };
  let rows = ALL;

  if (F.team!=='ALL') rows = rows.filter(r=>norm(r.Tag)===norm(F.team));
  if (F.opp!=='ALL')  rows = rows.filter(r=>norm(r['Vs Opponent'])===norm(F.opp));
  if (F.mode!=='ALL') rows = rows.filter(r=>norm(r.ModeN)===norm(F.mode));
  if (F.map!=='ALL')  rows = rows.filter(r=>norm(r.Map)===norm(F.map));
  if (F.stage!=='ALL')rows = rows.filter(r=>norm(r.Stage)===norm(F.stage));
  if (F.day!=='ALL')  rows = rows.filter(r=>String(r.Day)===String(F.day));
  if (F.q){
    rows = rows.filter(r=>{
      const hay = [r.Tag, r['Vs Opponent'], r.Map, r.ModeN, r.Stage, r.Series].map(x=>norm(x).toLowerCase()).join('|');
      return hay.includes(F.q);
    });
  }
  rows = rows.filter(r => cleanWL(r['W/L'])); // only valid W/L
  if (F.wl!=='ALL') rows = rows.filter(r=>cleanWL(r['W/L'])===F.wl);

  SCOPE = rows;

  el('meta').textContent =
   `Rows: ${SCOPE.length} / ${ALL.length} • Teams: ${distinct(SCOPE,'Tag').length} • Opponents: ${distinct(SCOPE,'Vs Opponent').length}`;
}

/* ===== Analytics helpers ===== */
function quickStats(rows){
  const games = rows.length;
  const w = rows.filter(r=>cleanWL(r['W/L'])==='W').length;
  const l = rows.filter(r=>cleanWL(r['W/L'])==='L').length;
  const ptsFor = sum(rows,'Score');
  const ptsAg  = sum(rows,'Opp Score');
  return { games, wins:w, losses:l, winrate: games ? (w/games) : 0, ptsFor, ptsAg, diff: ptsFor-ptsAg };
}
function byMode(rows){
  const g = groupBy(rows, r=>r.ModeN||'—');
  return Object.entries(g).map(([mode,list])=>{
    const qs = quickStats(list);
    return { mode, games:qs.games, wins:qs.wins, losses:qs.losses, winrate:qs.winrate };
  }).sort((a,b)=> {
    const ai = MODE_ORDER.indexOf(a.mode), bi = MODE_ORDER.indexOf(b.mode);
    return (ai-bi) || (b.winrate-a.winrate) || (b.games-a.games);
  });
}
function byMap(rows){
  const g = groupBy(rows, r=>norm(r.Map)||'—');
  return Object.entries(g).map(([map,list])=>{
    const qs = quickStats(list);
    return { map, games:qs.games, wins:qs.wins, losses:qs.losses, winrate:qs.winrate };
  }).sort((a,b)=> b.winrate-a.winrate || b.games-a.games);
}

/* ===== Render compact tables ===== */
function renderTable(hostId, rows, cols, empty='No rows.'){
  const host = el(hostId);
  if (!rows.length){ host.innerHTML = `<div class="muted">${empty}</div>`; return; }
  const thead = `<thead><tr>${cols.map(c=>`<th class="${c.right?'right':''}">${c.label}</th>`).join('')}</tr></thead>`;
  const tbody = `<tbody>${rows.map(r=>`<tr>${cols.map(c=>{
    let v = r[c.key];
    if (c.format==='pct') v = (typeof v==='number') ? (v*100).toFixed(1)+'%' : '—';
    if (c.format==='barpct'){
      const p = Math.max(0, Math.min(100, Math.round((r[c.key]||0)*100)));
      v = `<div class="bar"><span style="width:${p}%"></span></div>`;
    }
    return `<td class="${c.right?'right':''}">${v ?? '—'}</td>`;
  }).join('')}</tr>`).join('')}</tbody>`;
  host.innerHTML = `<table>${thead}${tbody}</table>`;
}

/* ===== Series viewer (balanced lanes; skip 0–0) ===== */
function renderSeriesCard(neutralKey){
  if (!neutralKey){ el('seriesCard').innerHTML = '<div class="muted" style="padding:12px">No series selected.</div>'; return; }
  const seriesRows = ALL.filter(r => seriesKeyNeutral(r) === neutralKey)
                        .sort((a,b)=> (n(a.MATCHES)-n(b.MATCHES)) || (n(a.id)-n(b.id)));
  if (!seriesRows.length){ el('seriesCard').innerHTML = '<div class="muted" style="padding:12px">Series not found.</div>'; return; }

  // pick left/right (keep selected team at left if chosen)
  const [stage,day,ser,pair] = neutralKey.split('|');
  let [A,B] = pair.split('~');
  const selTeam = norm(el('fTeam').value);
  if (selTeam && selTeam!=='ALL' && selTeam===B){ [A,B] = [B,A]; }

  // group by match index + map + mode; merge to one line
  const g = groupBy(seriesRows, r => `${n(r.MATCHES)}|${norm(r.Map)}|${norm(r.ModeN)}`);
  const linesRaw = Object.values(g).map(list=>{
    const ra = list.find(r=>norm(r.Tag)===A);
    const rb = list.find(r=>norm(r.Tag)===B);
    const map = norm((ra||rb||{}).Map);
    const mode = norm((ra||rb||{}).ModeN);
    const aScore = ra ? n(ra.Score) : (rb ? n(rb['Opp Score']) : 0);
    const bScore = rb ? n(rb.Score) : (ra ? n(ra['Opp Score']) : 0);
    return { idx:n((ra||rb||{}).MATCHES), map, mode, aScore, bScore };
  });
  // drop unplayed (0–0) lines to avoid visual noise
  const lines = linesRaw.filter(l => (l.aScore + l.bScore) > 0)
                        .sort((x,y)=>x.idx-y.idx);

  const played = lines.length;
  const aWins = lines.filter(l=>l.aScore>l.bScore).length;
  const bWins = lines.filter(l=>l.bScore>l.aScore).length;

  const head = `
    <div class="series-head">
      <div class="team-name">${A}</div>
      <div class="series-score">${aWins} : ${bWins} <span class="muted" style="font-weight:600"> (Bo${played})</span></div>
      <div class="opp-name">${B}</div>
      <div class="series-meta">${stage||'—'} • Day ${day||'—'} • Series ${ser||'—'}</div>
    </div>`;

  const body = lines.map(l=>{
    const aWin = l.aScore>l.bScore;
    const left  = `<div class="side side-left ${aWin?'':'dim'}"><span class="${aWin?'tick':'cross'}"></span><div class="scoreL">${l.aScore}</div></div>`;
    const mid   = `<div class="mode-stack"><span class="mode-pill">${l.mode||'—'}</span><div class="map-title">${l.map||'—'}</div></div>`;
    const right = `<div class="side side-right ${aWin?'dim':''}"><div class="scoreR">${l.bScore}</div><span class="${aWin?'cross':'tick'}"></span></div>`;
    return `<div class="map-row">${left}${mid}${right}</div>`;
  }).join('');

  const foot = `<div class="series-foot"><span>Maps played: ${played}</span><span>Pick a different series from the dropdown above.</span></div>`;
  el('seriesCard').innerHTML = head + body + foot;
}

/* ===== Standings (series-based) ===== */
function computeSeriesStandings(rows, modeFilter=null){
  const base = rows.filter(r=> cleanWL(r['W/L']) && (!modeFilter || r.ModeN===modeFilter));
  const bySeriesTeam = groupBy(base, r => `${seriesKeyNeutral(r)}|${norm(r.Tag)}`);
  const seriesOutcomes = Object.entries(bySeriesTeam).map(([key, list])=>{
    const wins = list.filter(r=>cleanWL(r['W/L'])==='W').length;
    const losses = list.filter(r=>cleanWL(r['W/L'])==='L').length;
    const team = norm(list[0].Tag);
    return { team, seriesWin: wins>losses ? 1 : 0, seriesLoss: wins<losses ? 1 : 0, mapsW:wins, mapsL:losses };
  });

  const agg = {};
  seriesOutcomes.forEach(r=>{
    const a = (agg[r.team] ||= { team:r.team, seriesW:0, seriesL:0, seriesP:0, mapsW:0, mapsL:0 });
    a.seriesW += r.seriesWin;
    a.seriesL += r.seriesLoss;
    a.seriesP += 1;
    a.mapsW   += r.mapsW;
    a.mapsL   += r.mapsL;
  });

  return Object.values(agg).map(r=>{
    const wr = r.seriesP ? (r.seriesW / r.seriesP) : 0;
    return { team:r.team, series_played:r.seriesP, series_wins:r.seriesW, series_losses:r.seriesL, winrate:wr,
             map_wins:r.mapsW, map_losses:r.mapsL, map_diff:(r.mapsW - r.mapsL) };
  }).sort((a,b)=> (b.winrate - a.winrate) || (b.series_wins - a.series_wins) || (b.map_diff - a.map_diff) || (b.map_wins-a.map_wins));
}

function renderStandings(){
  const overall = computeSeriesStandings(ALL);
  renderTable('standOverall', overall, [
    {label:'Team',key:'team'},
    {label:'Series',key:'series_played',right:true},
    {label:'W',key:'series_wins',right:true},
    {label:'L',key:'series_losses',right:true},
    {label:'Win %',key:'winrate',format:'pct',right:true},
    {label:'Map W',key:'map_wins',right:true},
    {label:'Map L',key:'map_losses',right:true},
    {label:'Diff',key:'map_diff',right:true},
  ], 'No series.');

  const host = el('standModes'); host.innerHTML = '';
  MODE_ORDER.forEach(m=>{
    const rows = computeSeriesStandings(ALL, m);
    const div = document.createElement('div');
    div.style.marginTop = '10px';
    div.innerHTML = `<h3>${m}</h3><div id="stand_${m.replace(/\W/g,'_')}"></div>`;
    host.appendChild(div);
    renderTable(`stand_${m.replace(/\W/g,'_')}`, rows, [
      {label:'Team',key:'team'},
      {label:'Series',key:'series_played',right:true},
      {label:'W',key:'series_wins',right:true},
      {label:'L',key:'series_losses',right:true},
      {label:'Win %',key:'winrate',format:'pct',right:true},
      {label:'Map W',key:'map_wins',right:true},
      {label:'Map L',key:'map_losses',right:true},
      {label:'Diff',key:'map_diff',right:true},
    ], '—');
  });
}

/* ===== Extra insights ===== */
function renderBestTeams(){
  const g = groupBy(SCOPE, r=>norm(r.Tag));
  const rows = Object.entries(g).map(([team,list])=>{
    const qs = quickStats(list);
    return { team, games:qs.games, wins:qs.wins, losses:qs.losses, winrate:qs.winrate };
  }).filter(r=>r.games>=5)
    .sort((a,b)=> b.winrate-a.winrate || b.games-a.games)
    .slice(0,12);
  renderTable('bestTeamsTbl', rows, [
    {label:'Team',key:'team'},
    {label:'G',key:'games',right:true},
    {label:'W',key:'wins',right:true},
    {label:'L',key:'losses',right:true},
    {label:'Win %',key:'winrate',format:'pct',right:true},
  ], '—');
}

function renderOpponents(){
  const g = groupBy(SCOPE, r=>norm(r['Vs Opponent']));
  const rows = Object.entries(g).map(([opp,list])=>{
    const qs = quickStats(list);
    return { opponent:opp||'—', games:qs.games, wins:qs.wins, losses:qs.losses, winrate:qs.winrate };
  }).sort((a,b)=> b.games-a.games).slice(0,12);
  renderTable('oppTbl', rows, [
    {label:'Opponent',key:'opponent'},
    {label:'G',key:'games',right:true},
    {label:'W',key:'wins',right:true},
    {label:'L',key:'losses',right:true},
    {label:'Win %',key:'winrate',format:'pct',right:true},
  ], '—');
}

function renderMatrix(){
  const byMapAll = byMap(SCOPE);
  const topMaps = byMapAll.slice(0,8).map(r=>r.map);
  const byModeMap = {}; MODE_ORDER.forEach(m=> byModeMap[m] = {});
  SCOPE.forEach(r=>{
    const m = r.ModeN || '—'; if (!MODE_ORDER.includes(m)) return;
    const map = norm(r.Map); if (!topMaps.includes(map)) return;
    const cell = (byModeMap[m][map] ||= {games:0,wins:0});
    cell.games += 1;
    cell.wins  += cleanWL(r['W/L'])==='W' ? 1 : 0;
  });
  const rows = MODE_ORDER.map(m=>{
    const row = { mode:m };
    topMaps.forEach(mp=>{
      const cell = byModeMap[m][mp] || {games:0,wins:0};
      row[mp] = cell.games ? `${pctStr(cell.wins, cell.games)} (${cell.games})` : '—';
    });
    return row;
  });
  const cols = [{label:'Mode',key:'mode'}].concat(topMaps.map(mp=>({label:mp,key:mp})));
  renderTable('matrixTbl', rows, cols, '—');
}

/* ===== Rows viewer ===== */
function renderRows(){
  const cols = [
    {label:'ID',key:'id'}, {label:'Team',key:'Tag'}, {label:'Opponent',key:'Vs Opponent'},
    {label:'Stage',key:'Stage'}, {label:'Day',key:'Day'}, {label:'Series',key:'Series'},
    {label:'Mode',key:'ModeN'}, {label:'Map',key:'Map'}, {label:'W/L',key:'W/L'},
    {label:'Score',key:'Score',right:true}, {label:'Opp',key:'Opp Score',right:true},
  ];
  renderTable('rowsTbl', SCOPE, cols, 'No rows in scope.');
}

/* ===== Main render ===== */
function renderAll(){
  setSeriesOptions(SCOPE);
  renderSeriesCard(el('fSeries').value);

  const q = quickStats(SCOPE);
  renderTable('quickTbl', [{
    games:q.games, wins:q.wins, losses:q.losses, winrate:q.winrate, points_for:q.ptsFor, points_against:q.ptsAg, diff:q.diff
  }], [
    {label:'Games',key:'games',right:true},
    {label:'Wins',key:'wins',right:true},
    {label:'Losses',key:'losses',right:true},
    {label:'Win %',key:'winrate',format:'pct',right:true},
    {label:'Pts For',key:'points_for',right:true},
    {label:'Pts Ag',key:'points_against',right:true},
    {label:'Diff',key:'diff',right:true},
  ]);

  const modes = byMode(SCOPE).map(r=>({mode:r.mode, games:r.games, wins:r.wins, losses:r.losses, winrate:r.winrate}));
  renderTable('modeTbl', modes, [
    {label:'Mode',key:'mode'}, {label:'G',key:'games',right:true},
    {label:'W',key:'wins',right:true}, {label:'L',key:'losses',right:true}, {label:'Win %',key:'winrate',format:'pct',right:true}
  ], '—');

  const maps = byMap(SCOPE).map(r=>({map:r.map, games:r.games, wins:r.wins, losses:r.losses, winrate:r.winrate}));
  renderTable('mapTbl', maps, [
    {label:'Map',key:'map'}, {label:'G',key:'games',right:true},
    {label:'W',key:'wins',right:true}, {label:'L',key:'losses',right:true}, {label:'Win %',key:'winrate',format:'pct',right:true}
  ], '—');

  renderRows();
  renderBestTeams();
  renderOpponents();
  renderMatrix();
}

/* ===== Wire up ===== */
el('applyBtn').onclick = ()=>{ applyFilters(); renderAll(); };
el('resetBtn').onclick = ()=>{
  ['fTeam','fOpp','fMode','fMap','fStage','fDay','fWL'].forEach(id=> el(id).value='ALL');
  el('fSearch').value = '';
  applyFilters(); renderAll();
};
el('exportBtn').onclick = ()=> download('codm_mp_scope.csv', toCSV(SCOPE));
el('fSeries').addEventListener('change', (e)=> renderSeriesCard(e.target.value));

/* ===== Boot ===== */
(async function init(){
  ALL = await fetchAll();
  ALL.forEach(r=>{
    r.Score = n(r.Score);
    r['Opp Score'] = n(r['Opp Score']);
    r.MATCHES = n(r.MATCHES);
    r.ModeN = normalizeMode(r.Mode);
    r['W/L'] = cleanWL(r['W/L']);
  });
  populateDropdowns();
  applyFilters();
  renderStandings();
  renderAll();
})();
</script>
</body>
</html>
