<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>COD:M — Map Layouts (Pan & Zoom)</title>

<style>
  :root{
    --bg:#0d1014; --panel:#1b2130; --panel2:#121724;
    --ink:#eef3fb; --muted:#b6c0ce; --line:#343c4b;
    --brand:#ffe93b; --accent:#7fd2ff;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif}

  /* Header */
  header{position:sticky;top:0;z-index:10;background:linear-gradient(180deg,#131823 0%,#0d1014 100%);border-bottom:2px solid var(--brand)}
  .head{max-width:1200px;margin:0 auto;padding:10px 14px;display:flex;align-items:center;gap:12px}
  .logo{height:28px;aspect-ratio:auto;display:block}
  h1{margin:0;font-size:1.05rem;letter-spacing:.2px}
  .spacer{flex:1}
  .btn{background:var(--brand);color:#0b0f14;border:0;border-radius:10px;padding:8px 12px;font-weight:800;cursor:pointer}
  .btn.secondary{background:#171d2a;color:#dbe3f0;border:1px solid var(--line)}
  a.btn{display:inline-flex;align-items:center;gap:8px;text-decoration:none}

  /* Layout */
  .shell{max-width:1200px;margin:16px auto;padding:0 12px}
  .grid{
    display:grid; gap:14px; grid-template-columns:1fr;
    grid-template-areas: "viewer" "maps";
  }
  @media (min-width:768px){
    .grid{ grid-template-columns:360px 1fr; grid-template-areas:"maps viewer"; }
  }
  .panel{ grid-area: maps; }
  .viewer{ grid-area: viewer; }

  /* Panels */
  .panel{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:12px}
  .panel h2{margin:0 0 8px 0;font-size:1rem}

  /* Search */
  .search{display:flex;gap:8px;margin-bottom:10px}
  .search input{flex:1;background:#0f1421;color:var(--ink);border:1px solid var(--line);border-radius:10px;padding:8px 10px}

  /* Buttons */
  .mode-section{margin-bottom:10px}
  .mode-title{margin:6px 0 8px 0;font-weight:800;color:#fff}

  /* Map list */
  .map-list{ display:grid; grid-template-columns: 1fr; gap:8px; }
  @media (max-width: 1000px){ .map-list{ grid-template-columns: repeat(3, minmax(80px, 1fr)); } }
  @media (max-width: 600px){ .map-list{ grid-template-columns: repeat(2, minmax(120px, 1fr)); } }

  .map-btn{
    background:#0f1524;border:1px solid var(--line);color:#dfe7f5;border-radius:12px;
    padding:10px 10px; text-align:center; cursor:pointer; user-select:none;
    transition:transform .05s ease, border-color .2s ease, background .2s ease;
  }
  .map-btn:hover{transform:translateY(-1px);border-color:#4b9bd6}
  .map-btn.active{background:#152036;border-color:var(--accent);box-shadow:0 0 0 2px #152036, 0 0 0 4px rgba(127,210,255,.25) inset}

  /* Viewer */
  .viewer{background:var(--panel2);border:1px solid var(--line);border-radius:14px;padding:10px}
  .viewer-head{display:flex;align-items:center;gap:10px;margin:0 0 10px 0;flex-wrap:wrap}
  .viewer-title{font-weight:800}
  .viewer-tools{margin-left:auto;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .viewer-tools .btn{padding:6px 10px}
  .viewer-tools .meter{min-width:52px;text-align:center;font-variant-numeric:tabular-nums}

  /* HP Variant Bar */
  .variant-bar{
    display:flex;gap:8px;flex-wrap:wrap;margin:6px 0 8px 0;
  }
  .seg-btn{
    background:#0f1524;border:1px solid var(--line);color:#dfe7f5;border-radius:999px;
    padding:6px 10px; font-size:.9rem; cursor:pointer; user-select:none;
    transition:transform .05s ease, border-color .2s ease, background .2s ease;
  }
  .seg-btn:hover{transform:translateY(-1px);border-color:#4b9bd6}
  .seg-btn.active{background:#152036;border-color:var(--accent);box-shadow:0 0 0 2px #152036, 0 0 0 4px rgba(127,210,255,.25) inset}

  /* Pan+Zoom Stage */
  .img-wrap{
    position:relative; width:100%; height:72vh; min-height:360px;
    background:#0a0e18; border:1px solid var(--line); border-radius:12px;
    overflow:hidden; touch-action:none; user-select:none;
  }
  #stage{ position:absolute; will-change:transform,width,height; }
  #stage img{ width:100%; height:100%; object-fit:contain; display:block; pointer-events:none; }

  .muted{color:var(--muted)}
</style>
</head>
<body>
<header>
  <div class="head">
    <img src="https://i.imgur.com/K0TTjUC.png" alt="COD:M logo" class="logo" />
    <h1>COD:M — Map Layouts</h1>
    <div class="spacer"></div>
    <a class="btn secondary" href="index.html" title="Back to Home">⟵ Home</a>
  </div>
</header>

<div class="shell">
  <div class="grid">
    <!-- Left: maps grouped by mode (moves below on small screens) -->
    <section class="panel">
      <h2>Maps</h2>
      <div class="search">
        <input id="q" type="search" placeholder="Filter maps…" />
        <button class="btn secondary" id="clearBtn">Clear</button>
      </div>

      <div id="groups"></div>
      <p class="muted" id="countNote" style="margin-top:8px"></p>
    </section>

    <!-- Right: viewer -->
    <section class="viewer">
      <div class="viewer-head">
        <div>
          <div class="viewer-title" id="title">Select a map</div>
          <!-- Variant buttons appear here when a Hardpoint map is selected -->
          <div id="variantBar" class="variant-bar" style="display:none"></div>
        </div>
        <div class="viewer-tools">
          <button class="btn secondary" id="zoomOut" title="Zoom out (Ctrl/⌘ -)">−</button>
          <button class="btn secondary meter" id="zoomMeter" title="Reset view (Ctrl/⌘ 0)">100%</button>
          <button class="btn secondary" id="zoomIn" title="Zoom in (Ctrl/⌘ +)">+</button>
          <a id="openLink" class="btn secondary" href="#" target="_blank" rel="noopener">Open</a>
          <a id="downloadLink" class="btn" href="#" download>Download</a>
        </div>
      </div>

      <div class="img-wrap" id="wrap">
        <div id="stage"><img id="img" alt="Map layout preview" /></div>
      </div>
      <p class="muted" style="margin-top:10px">
        Default shows the entire image (no scroll). Drag to <b>pan</b> when zoomed. Use <b>+</b>/<b>−</b>, Ctrl/⌘ + scroll, or pinch to <b>zoom</b>.
      </p>
    </section>
  </div>
</div>

<script>
  /* === Source images (default "All" images) === */
  const MAPS = [
    {name:'Coastal', url:'https://i.imgur.com/2JRlrj5.png'},
    {name:'Crossfire', url:'https://i.imgur.com/YYor9iP.png'},
    {name:'Firing Range', url:'https://i.imgur.com/QWJg4Ai.png'},
    {name:'Kurohana Metropolis', url:'https://i.imgur.com/eeYVgRp.png'},
    {name:'Raid', url:'https://i.imgur.com/cGh1ku0.png'},
    {name:'Standoff', url:'https://i.imgur.com/8gaEr2j.png'},
    {name:'Tunisia', url:'https://i.imgur.com/D23jrcJ.png'},
    {name:'Apocalypse', url:'https://i.imgur.com/vPi4xxR.png'},
    {name:'Hacienda', url:'https://i.imgur.com/MUd5sW2.png'},
    {name:'Slums', url:'https://i.imgur.com/lVNINxG.png'},
    {name:'Summit', url:'https://i.imgur.com/Uk13UO0.png'},
    {name:'Takeoff', url:'https://i.imgur.com/OofTHfO.png'},
    {name:'Combine', url:'https://i.imgur.com/GQHcMPq.png'}
  ];

  /* === Grouping by mode === */
  const MAPS_BY_MODE = {
    'Hardpoint':        ['Summit','Hacienda','Apocalypse','Slums','Combine'],
    'Search & Destroy': ['Tunisia','Firing Range','Kurohana Metropolis','Standoff','Coastal'],
    'Control':          ['Raid','Takeoff','Crossfire']
  };
  const MODE_ORDER = ['Hardpoint','Search & Destroy','Control'];

  /* === Hardpoint Variants (All, P1..P4) === */
  const HP_VARIANTS = {
    'Apocalypse': {
      'All':'https://i.imgur.com/djfhXIE.png',
      'P1':'https://i.imgur.com/9NVdBgP.png',
      'P2':'https://i.imgur.com/u8Nogpu.png',
      'P3':'https://i.imgur.com/x1x4wwq.png',
      'P4':'https://i.imgur.com/ObpgHDH.png'
    },
    'Combine': {
      'All':'https://i.imgur.com/DtBhN36.png',
      'P1':'https://i.imgur.com/gtI51o8.png',
      'P2':'https://i.imgur.com/rM5RqqB.png',
      'P3':'https://i.imgur.com/932Edc6.png',
      'P4':'https://i.imgur.com/rRR7930.png'
    },
    'Hacienda': {
      'All':'https://i.imgur.com/aOWvPKU.png',
      'P1':'https://i.imgur.com/KD4KFCx.jpeg',
      'P2':'https://i.imgur.com/xu93Wnw.jpeg',
      'P3':'https://i.imgur.com/cTnO39Y.jpeg',
      'P4':'https://i.imgur.com/zmnepDg.jpeg'
    },
    'Slums': {
      'All':'https://i.imgur.com/9y2NzWw.png',
      'P1':'https://i.imgur.com/w0NAEaD.png',
      'P2':'https://i.imgur.com/hYg1XDM.png',
      'P3':'https://i.imgur.com/4MUlecf.png',
      'P4':'https://i.imgur.com/UmbYAb0.png'
    },
    'Summit': {
      'All':'https://i.imgur.com/yevs7pE.png',
      'P1':'https://i.imgur.com/FcT6RBE.jpeg',
      'P2':'https://i.imgur.com/pAwsWEp.jpeg',
      'P3':'https://i.imgur.com/aQ7XvtZ.jpeg',
      'P4':'https://i.imgur.com/sW3SNwA.jpeg'
    }
  };

  const groupsEl   = document.getElementById('groups');
  const titleEl    = document.getElementById('title');
  const variantBar = document.getElementById('variantBar');

  const wrap       = document.getElementById('wrap');
  const stage      = document.getElementById('stage');
  const imgEl      = document.getElementById('img');

  const openLink   = document.getElementById('openLink');
  const dlLink     = document.getElementById('downloadLink');
  const q          = document.getElementById('q');
  const clearBtn   = document.getElementById('clearBtn');
  const countNote  = document.getElementById('countNote');

  const zoomOutBtn = document.getElementById('zoomOut');
  const zoomInBtn  = document.getElementById('zoomIn');
  const zoomMeter  = document.getElementById('zoomMeter');

  let flatFiltered = []; // visible ordered map names
  let activeName = '';   // current map
  let activeVariant = 'All'; // HP segment (All/P1/P2/P3/P4)

  /* === Pan & Zoom state === */
  let naturalW = 0, naturalH = 0;
  let baseScale = 1;
  let zoom = 1;
  let offsetX = 0, offsetY = 0;
  const Z_MIN = 1, Z_MAX = 6, Z_STEP = 0.2;

  const clamp = (v,a,b)=> Math.min(Math.max(v,a),b);
  const effScale = ()=> baseScale * zoom;

  function updateZoomMeter(){ zoomMeter.textContent = Math.round(effScale()/baseScale*100) + '%'; }

  function setStage(){
    const s = effScale();
    const w = naturalW * s, h = naturalH * s;
    stage.style.width  = w + 'px';
    stage.style.height = h + 'px';
    stage.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
  }

  function centerStage(){
    const s = effScale();
    const w = naturalW * s, h = naturalH * s;
    offsetX = Math.round((wrap.clientWidth  - w)/2);
    offsetY = Math.round((wrap.clientHeight - h)/2);
  }

  function clampOffsets(){
    const s = effScale();
    const w = naturalW * s, h = naturalH * s;

    if (w <= wrap.clientWidth){
      offsetX = Math.round((wrap.clientWidth - w)/2);
    } else {
      const minX = wrap.clientWidth - w, maxX = 0;
      offsetX = clamp(offsetX, minX, maxX);
    }
    if (h <= wrap.clientHeight){
      offsetY = Math.round((wrap.clientHeight - h)/2);
    } else {
      const minY = wrap.clientHeight - h, maxY = 0;
      offsetY = clamp(offsetY, minY, maxY);
    }
  }

  function fitToView(){
    if (!naturalW || !naturalH) return;
    baseScale = Math.min(
      wrap.clientWidth  / naturalW,
      wrap.clientHeight / naturalH
    );
    zoom = 1;
    centerStage();
    setStage();
    updateZoomMeter();
  }

  function zoomAtFactor(factor, anchorX, anchorY){
    const prevS = effScale();
    const cx = (anchorX - offsetX) / prevS;
    const cy = (anchorY - offsetY) / prevS;

    zoom = clamp(zoom * factor, Z_MIN, Z_MAX);

    const nextS = effScale();
    offsetX = anchorX - cx * nextS;
    offsetY = anchorY - cy * nextS;

    clampOffsets();
    setStage();
    updateZoomMeter();
  }

  function zoomStep(dir, anchorX = wrap.clientWidth/2, anchorY = wrap.clientHeight/2){
    const factor = dir > 0 ? (1+Z_STEP) : 1/(1+Z_STEP);
    zoomAtFactor(factor, anchorX, anchorY);
  }

  function handleResize(){
    if (!naturalW || !naturalH) return;
    const prevS = effScale();
    const centerX = wrap.clientWidth/2, centerY = wrap.clientHeight/2;
    const cx = (centerX - offsetX) / prevS;
    const cy = (centerY - offsetY) / prevS;

    baseScale = Math.min(wrap.clientWidth / naturalW, wrap.clientHeight / naturalH);
    zoom = clamp(prevS / baseScale, Z_MIN, Z_MAX);

    const nextS = effScale();
    offsetX = centerX - cx * nextS;
    offsetY = centerY - cy * nextS;

    clampOffsets();
    setStage();
    updateZoomMeter();
  }
  window.addEventListener('resize', ()=> requestAnimationFrame(handleResize));

  /* === Panning (mouse/touch) === */
  (function panGesture(){
    let dragging = false, sx=0, sy=0, ox=0, oy=0;
    const start = (x,y)=>{ dragging = true; sx=x; sy=y; ox=offsetX; oy=offsetY; };
    const move = (x,y)=>{ if (!dragging) return; offsetX = ox + (x - sx); offsetY = oy + (y - sy); clampOffsets(); setStage(); };
    const end = ()=> { dragging = false; };

    wrap.addEventListener('mousedown', (e)=>{ if (e.button!==0) return; e.preventDefault(); start(e.clientX, e.clientY); });
    window.addEventListener('mousemove', (e)=> move(e.clientX, e.clientY));
    window.addEventListener('mouseup', end);

    let touchId = null;
    wrap.addEventListener('touchstart', (e)=>{ if (e.touches.length===1){ const t = e.touches[0]; touchId=t.identifier; start(t.clientX,t.clientY);} }, {passive:true});
    wrap.addEventListener('touchmove', (e)=>{ if (touchId==null) return; const t=[...e.touches].find(t=>t.identifier===touchId); if (t) move(t.clientX,t.clientY); }, {passive:true});
    wrap.addEventListener('touchend', ()=>{ touchId=null; end(); }, {passive:true});
    wrap.addEventListener('touchcancel', ()=>{ touchId=null; end(); }, {passive:true});
  })();

  /* === Pinch Zoom === */
  (function pinchZoom(){
    let p1=null, p2=null;
    function dist(a,b){ const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY; return Math.hypot(dx,dy); }
    function mid(a,b){ return {x:(a.clientX+b.clientX)/2, y:(a.clientY+b.clientY)/2}; }

    wrap.addEventListener('touchstart', (e)=>{ if (e.touches.length===2){ p1=e.touches[0]; p2=e.touches[1]; wrap.dataset.pinchD=dist(p1,p2); const m=mid(p1,p2); wrap.dataset.pinchX=m.x; wrap.dataset.pinchY=m.y; } }, {passive:true});
    wrap.addEventListener('touchmove', (e)=>{ if (e.touches.length!==2 || !wrap.dataset.pinchD) return; const d0=parseFloat(wrap.dataset.pinchD)||0; if (!d0) return; const n1=e.touches[0], n2=e.touches[1]; const d1=dist(n1,n2); const m=mid(n1,n2); const ax=parseFloat(wrap.dataset.pinchX||m.x); const ay=parseFloat(wrap.dataset.pinchY||m.y); const factor=d1/d0; zoomAtFactor(factor, ax, ay); wrap.dataset.pinchD=d1; wrap.dataset.pinchX=m.x; wrap.dataset.pinchY=m.y; }, {passive:true});
    wrap.addEventListener('touchend', ()=>{ p1=p2=null; delete wrap.dataset.pinchD; delete wrap.dataset.pinchX; delete wrap.dataset.pinchY; }, {passive:true});
    wrap.addEventListener('touchcancel', ()=>{ p1=p2=null; delete wrap.dataset.pinchD; delete wrap.dataset.pinchX; delete wrap.dataset.pinchY; }, {passive:true});
  })();

  /* === Wheel zoom (with Ctrl/⌘) === */
  wrap.addEventListener('wheel', (e)=>{
    if (e.ctrlKey || e.metaKey){
      e.preventDefault();
      const factor = e.deltaY < 0 ? 1.1 : 1/1.1;
      zoomAtFactor(factor, e.clientX, e.clientY);
    }
  }, {passive:false});

  /* === Buttons + keyboard zoom === */
  zoomInBtn.addEventListener('click', ()=> zoomStep(+1));
  zoomOutBtn.addEventListener('click',()=> zoomStep(-1));
  zoomMeter.addEventListener('click', ()=> fitToView());
  window.addEventListener('keydown', (e)=>{
    if (e.ctrlKey || e.metaKey){
      if (e.key==='+' || e.key==='='){ e.preventDefault(); zoomStep(+1); }
      if (e.key==='-'){ e.preventDefault(); zoomStep(-1); }
      if (e.key==='0'){ e.preventDefault(); fitToView(); }
    }
  });

  /* === Map list rendering === */
  function findGlobalMap(name){
    return MAPS.find(m => m.name.toLowerCase() === name.toLowerCase());
  }
  const isHPMap = (name)=> (MAPS_BY_MODE['Hardpoint']||[]).map(n=>n.toLowerCase()).includes(String(name).toLowerCase());

  function renderGroups(){
    const term = (q.value||'').trim().toLowerCase();
    flatFiltered = [];
    groupsEl.innerHTML = '';

    MODE_ORDER.forEach(mode=>{
      const names = MAPS_BY_MODE[mode].filter(n => n.toLowerCase().includes(term));
      if (!names.length) return;

      const sec = document.createElement('div');
      sec.className = 'mode-section';

      const h = document.createElement('div');
      h.className = 'mode-title';
      h.textContent = mode;
      sec.appendChild(h);

      const list = document.createElement('div');
      list.className = 'map-list';

      names.forEach(n=>{
        const m = findGlobalMap(n);
        if (!m) return;
        flatFiltered.push(m.name);

        const b = document.createElement('button');
        b.className = 'map-btn';
        b.textContent = m.name;
        b.dataset.name = m.name;
        b.onclick = () => selectName(m.name, 'All'); // default to 'All' on map switch
        list.appendChild(b);
      });

      sec.appendChild(list);
      groupsEl.appendChild(sec);
    });

    const total = Object.values(MAPS_BY_MODE).flat().length;
    countNote.textContent = `${flatFiltered.length} of ${total} maps`;

    applyActiveStyle();
    if (flatFiltered.length && !flatFiltered.includes(activeName)){
      selectName(flatFiltered[0], 'All');
    }
  }

  function applyActiveStyle(){
    groupsEl.querySelectorAll('.map-btn').forEach(btn=>{
      btn.classList.toggle('active', btn.dataset.name === activeName);
    });
    // variant buttons highlight
    [...variantBar.querySelectorAll('.seg-btn')].forEach(b=>{
      b.classList.toggle('active', b.dataset.seg === activeVariant);
    });
  }

  function getCurrentURL(name, variant){
    if (isHPMap(name) && HP_VARIANTS[name] && HP_VARIANTS[name][variant]) {
      return HP_VARIANTS[name][variant];
    }
    const m = findGlobalMap(name);
    return m ? m.url : '';
  }

  function renderVariantButtons(name){
    // show only for HP maps with known variants
    if (!isHPMap(name) || !HP_VARIANTS[name]) {
      variantBar.style.display = 'none';
      variantBar.innerHTML = '';
      return;
    }
    const segments = ['All','P1','P2','P3','P4'].filter(s => HP_VARIANTS[name][s]);
    variantBar.innerHTML = segments.map(seg =>
      `<button class="seg-btn" data-seg="${seg}" title="${name} — ${seg}">${seg}</button>`
    ).join('');
    variantBar.style.display = '';
    // wire events
    [...variantBar.querySelectorAll('.seg-btn')].forEach(btn=>{
      btn.addEventListener('click', ()=>{
        activeVariant = btn.dataset.seg || 'All';
        const url = getCurrentURL(activeName, activeVariant);
        titleEl.textContent = `${activeName} — ${activeVariant}`;
        imgEl.src = url;
        imgEl.alt = `${activeName} ${activeVariant} layout`;
        openLink.href = url;
        dlLink.href = url;
        applyActiveStyle();
      });
    });
    applyActiveStyle();
  }

  function selectName(name, variant='All'){
    const base = findGlobalMap(name);
    if (!base) return;

    activeName = base.name;
    activeVariant = variant;

    renderVariantButtons(activeName);

    const url = getCurrentURL(activeName, activeVariant);
    titleEl.textContent = isHPMap(activeName) ? `${activeName} — ${activeVariant}` : activeName;
    imgEl.src = url;
    imgEl.alt = `${activeName} map layout`;
    openLink.href = url;
    dlLink.href = url;
    applyActiveStyle();
  }

  // On image load, capture intrinsic size then fit
  imgEl.addEventListener('load', ()=>{
    requestAnimationFrame(()=>{
      naturalW = imgEl.naturalWidth || imgEl.width;
      naturalH = imgEl.naturalHeight || imgEl.height;
      fitToView();
    });
  });

  // Keyboard navigation across filtered order
  window.addEventListener('keydown', (e)=>{
    if (!flatFiltered.length) return;
    if (e.ctrlKey || e.metaKey) return;
    const idx = flatFiltered.indexOf(activeName);
    if (['ArrowDown','ArrowRight'].includes(e.key)){
      e.preventDefault();
      const next = (idx + 1 + flatFiltered.length) % flatFiltered.length;
      selectName(flatFiltered[next], 'All');
    } else if (['ArrowUp','ArrowLeft'].includes(e.key)){
      e.preventDefault();
      const prev = (idx - 1 + flatFiltered.length) % flatFiltered.length;
      selectName(flatFiltered[prev], 'All');
    }
  });

  // Preload defaults and HP variants
  [...MAPS.map(m=>m.url),
   ...Object.values(HP_VARIANTS).flatMap(obj=>Object.values(obj))
  ].forEach(src => { const im = new Image(); im.src = src; });

  // Search wiring
  q.addEventListener('input', renderGroups);
  clearBtn.addEventListener('click', ()=>{ q.value=''; renderGroups(); });

  // Initial render
  renderGroups();
  if (flatFiltered.length) selectName(flatFiltered[0], 'All');
</script>
</body>
</html>
