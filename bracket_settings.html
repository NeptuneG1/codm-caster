<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>Tournament Bracketing ‚Äî Settings</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

  <style>
    :root{
      --bg:#05060a;
      --panel:#111524;
      --panel2:#181d2f;
      --ink:#f6f7fb;
      --muted:#a3acc3;
      --brand:#ffe93b;
      --brand-soft:rgba(255,233,59,.14);
      --accent:#7fd2ff;
      --danger:#ff6b6b;
      --line:#262b3d;
      --radius-lg:16px;
      --radius-sm:8px;
    }

    *{box-sizing:border-box;margin:0;padding:0}
    html,body{
      height:100%;
      background:radial-gradient(circle at top,#171c30 0,#05060a 52%);
      color:var(--ink);
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"SF Pro Text",Segoe UI,Roboto,sans-serif;
    }

    body{
      display:flex;
      justify-content:center;
      padding:16px;
    }

    .app{
      width:100%;
      max-width:1280px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    header{
      padding:12px 18px;
      border-radius:var(--radius-lg);
      background:linear-gradient(135deg,#171c30,#111524);
      border:1px solid var(--line);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
    }
    header h1{
      font-size:1.1rem;
      letter-spacing:.04em;
      text-transform:uppercase;
    }
    header span.sub{
      font-size:.8rem;
      color:var(--muted);
    }

    .header-right{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    #tournament-select{
      background:var(--panel2);
      border-radius:999px;
      border:1px solid var(--line);
      color:var(--ink);
      padding:4px 8px;
      font-size:.78rem;
      max-width:260px;
      cursor:pointer;
    }
    #tournament-select:focus{
      outline:none;
      border-color:var(--accent);
      box-shadow:0 0 0 1px rgba(127,210,255,.3);
    }

    main{
      display:grid;
      grid-template-columns:320px minmax(260px,360px) 1fr;
      gap:12px;
      align-items:flex-start;
    }

    section{
      border-radius:var(--radius-lg);
      background:var(--panel);
      border:1px solid var(--line);
      padding:12px;
      min-height:0;
    }

    section h2{
      font-size:.9rem;
      text-transform:uppercase;
      letter-spacing:.08em;
      color:var(--muted);
      margin-bottom:8px;
    }

    /* Settings panel */
    .settings-grid{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .field{
      display:flex;
      flex-direction:column;
      gap:4px;
      font-size:.82rem;
    }
    .field label{
      color:var(--muted);
      display:flex;
      justify-content:space-between;
      gap:8px;
    }
    .field small{
      font-size:.7rem;
      color:var(--muted);
    }
    .field input[type="text"],
    .field input[type="number"],
    .field select{
      background:var(--panel2);
      border-radius:var(--radius-sm);
      border:1px solid var(--line);
      color:var(--ink);
      padding:6px 8px;
      font-size:.85rem;
      outline:none;
    }
    .field input[type="text"]:focus,
    .field input[type="number"]:focus,
    .field select:focus{
      border-color:var(--accent);
      box-shadow:0 0 0 1px rgba(127,210,255,.3);
    }
    .field-row{
      display:flex;
      gap:8px;
    }
    .field-row > *{flex:1}

    .checkbox-row{
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:.8rem;
      color:var(--muted);
      margin-top:4px;
    }
    .checkbox-row input{
      accent-color:var(--brand);
    }

    .settings-actions{
      margin-top:8px;
      display:flex;
      flex-wrap:wrap;
      gap:6px;
    }

    button{
      border:none;
      border-radius:999px;
      padding:6px 10px;
      font-size:.8rem;
      background:var(--panel2);
      color:var(--ink);
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:4px;
      transition:background .15s, transform .05s, box-shadow .15s;
    }
    button span.icon{
      font-size:.9rem;
    }
    button.primary{
      background:var(--brand);
      color:#05060a;
      font-weight:600;
      box-shadow:0 0 0 1px rgba(0,0,0,.5);
    }
    button.primary:hover{
      background:#fff39a;
    }
    button:hover{
      background:#20263a;
      transform:translateY(-1px);
    }
    button:active{
      transform:translateY(0);
      box-shadow:none;
    }
    button:disabled{
      opacity:.5;
      cursor:default;
      transform:none;
    }

    /* Stage editor */
    .stage-row{
      display:flex;
      align-items:center;
      gap:6px;
      margin-bottom:4px;
    }
    .stage-row span.stage-index{
      font-size:.75rem;
      color:var(--muted);
      width:64px;
      flex-shrink:0;
    }
    .stage-row input.stage-name{
      flex:1;
    }
    .stage-row input.stage-qualifiers{
      width:72px;
    }
    .stage-row small.stage-qualify{
      font-size:.7rem;
      color:var(--muted);
      white-space:nowrap;
    }
    .stage-row button.remove-stage{
      padding:2px 6px;
      font-size:.7rem;
    }

    /* Participants */
    .participants-table{
      width:100%;
      border-collapse:collapse;
      font-size:.8rem;
      margin-top:4px;
      border-radius:var(--radius-sm);
      overflow:hidden;
    }
    .participants-table thead{
      background:var(--panel2);
    }
    .participants-table th,
    .participants-table td{
      padding:6px 6px;
      border-bottom:1px solid var(--line);
    }
    .participants-table th{
      text-align:left;
      color:var(--muted);
      font-weight:500;
    }
    .participants-table td.seed-cell{
      width:40px;
      color:var(--muted);
    }
    .participants-table input[type="text"]{
      width:100%;
      background:transparent;
      border:none;
      border-bottom:1px dashed rgba(255,255,255,.1);
      padding:2px;
      font-size:.8rem;
      color:var(--ink);
      outline:none;
    }
    .participants-table input[type="text"]:focus{
      border-bottom-color:var(--accent);
    }
    .participants-table tbody tr:nth-child(even){
      background:rgba(0,0,0,.06);
    }
    .pill{
      display:inline-flex;
      align-items:center;
      padding:2px 6px;
      border-radius:999px;
      background:var(--panel2);
      font-size:.72rem;
      color:var(--muted);
    }
    .pill span.dot{
      width:6px;height:6px;border-radius:50%;background:var(--brand);margin-right:4px;
    }

    .helper-text{
      font-size:.72rem;
      color:var(--muted);
      margin-top:6px;
      line-height:1.4;
    }

    /* Bracket */
    .bracket-shell{
      display:flex;
      flex-direction:column;
      gap:8px;
      min-height:220px;
    }
    .bracket-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:.8rem;
      color:var(--muted);
    }

    .bracket-container{
      display:flex;
      align-items:flex-start;
      gap:12px;
      overflow-x:auto;
      padding-bottom:4px;
    }
    .round-col{
      min-width:180px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .round-title{
      font-size:.8rem;
      text-transform:uppercase;
      letter-spacing:.08em;
      color:var(--muted);
      margin-bottom:2px;
    }
    .match-card{
      background:var(--panel2);
      border-radius:var(--radius-sm);
      border:1px solid var(--line);
      padding:6px;
      display:flex;
      flex-direction:column;
      gap:4px;
      box-shadow:0 8px 12px rgba(0,0,0,.35);
    }
    .match-meta{
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:.7rem;
      color:var(--muted);
    }
    .match-meta span.badge{
      padding:1px 6px;
      border-radius:999px;
      background:var(--brand-soft);
      color:var(--brand);
      font-weight:500;
      text-transform:uppercase;
      letter-spacing:.06em;
      font-size:.67rem;
    }
    .player-row{
      display:grid;
      grid-template-columns:22px minmax(0,1fr) 40px;
      align-items:center;
      gap:4px;
      font-size:.8rem;
    }
    .player-row span.seed{
      font-size:.7rem;
      color:var(--muted);
      text-align:right;
    }
    .player-row span.name{
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .player-row.bye span.name{
      color:var(--muted);
      opacity:.7;
      font-style:italic;
    }
    .player-row input.score-input{
      width:100%;
      text-align:center;
      background:#05060a;
      border-radius:6px;
      border:1px solid var(--line);
      color:var(--ink);
      padding:3px;
      font-size:.78rem;
      outline:none;
    }
    .player-row input.score-input:focus{
      border-color:var(--accent);
    }

    .match-actions{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-top:2px;
      gap:4px;
    }
    .match-actions button{
      padding:4px 8px;
      font-size:.72rem;
    }
    .match-status{
      font-size:.7rem;
      color:var(--muted);
    }
    .match-status .winner-tag{
      color:var(--brand);
      font-weight:600;
    }
    .match-status .pending{
      color:var(--muted);
    }

    .empty-state{
      font-size:.8rem;
      color:var(--muted);
      padding:18px 10px;
      border-radius:var(--radius-sm);
      background:rgba(0,0,0,.14);
      border:1px dashed rgba(255,255,255,.08);
    }

    #save-status{
      font-size:.72rem;
      color:var(--muted);
      margin-top:4px;
    }

    @media(max-width:1040px){
      main{
        grid-template-columns:minmax(0,1fr);
      }
      section:nth-child(2){
        order:3;
      }
      section:nth-child(3){
        order:2;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <h1>Tournament Bracketing ‚Äî Settings</h1>
        <span class="sub">Configure participants, generate bracket, and push to database</span>
      </div>
      <div class="header-right">
        <select id="tournament-select">
          <option>Loading‚Ä¶</option>
        </select>
        <div class="pill">
          <span class="dot"></span>
          <span id="save-status-pill">Not saved to database</span>
        </div>
      </div>
    </header>

    <main>
      <!-- SETTINGS -->
      <section id="settings-section">
        <h2>Settings</h2>
        <div class="settings-grid">
          <div class="field">
            <label>
              Tournament Name
            </label>
            <input type="text" id="tournament-name" placeholder="My Tournament"/>
          </div>

          <div class="field field-row">
            <div>
              <label>Format</label>
              <select id="tournament-format">
                <option value="single">Single Elimination</option>
                <option value="double" disabled>Double Elim (stub)</option>
                <option value="roundrobin" disabled>Round Robin (stub)</option>
                <option value="swiss" disabled>Swiss (stub)</option>
              </select>
            </div>
            <div>
              <label>Best Of</label>
              <select id="best-of">
                <option value="1">Bo1</option>
                <option value="3" selected>Bo3</option>
                <option value="5">Bo5</option>
                <option value="7">Bo7</option>
              </select>
            </div>
          </div>

          <div class="field">
            <label>Seeding Mode</label>
            <select id="seeding-mode">
              <option value="seeded">Traditional (1 vs last)</option>
              <option value="list">List order</option>
              <option value="random">Randomize</option>
            </select>
            <small>Traditional seeding keeps top seeds apart until later rounds, similar to Challonge.</small>
          </div>

          <div class="checkbox-row">
            <span>3rd place match</span>
            <input type="checkbox" id="third-place-toggle"/>
          </div>

          <!-- NEW: multi-stage configuration -->
          <div class="field">
            <label>
              Stages &amp; Qualification
              <span style="font-size:.75rem;color:var(--muted);">Top X advance to next stage</span>
            </label>
            <div id="stages-container"></div>
            <button type="button" id="add-stage-btn" style="margin-top:4px;">
              <span class="icon">‚ûï</span>
              Add stage
            </button>
            <small>Example: Stage 1 ‚Äì Groups (Top 12 qualify), Stage 2 ‚Äì Finals (Top 1 champion).</small>
          </div>

          <div class="settings-actions">
            <button id="add-participant-btn">
              <span class="icon">Ôºã</span>
              Add participant
            </button>
            <button id="shuffle-btn">
              <span class="icon">üé≤</span>
              Shuffle list
            </button>
            <button id="clear-btn">
              <span class="icon">üßπ</span>
              Clear all
            </button>
            <button class="primary" id="generate-btn">
              <span class="icon">üèÜ</span>
              Generate bracket
            </button>
            <button class="primary" id="save-btn">
              <span class="icon">üíæ</span>
              Save bracket to database
            </button>
          </div>

          <p class="helper-text">
            1) Select tournament (or create new) ‚Ä¢ 2) Add participants ‚Ä¢ 3) Generate bracket ‚Ä¢ 4) Report scores ‚Ä¢ 5) Save/update.  
            Public can view on <code>bracket_view.html</code>.
          </p>
          <!-- live bracket math helper -->
          <p id="bracket-math" class="helper-text"></p>

          <p id="save-status"></p>
        </div>
      </section>

      <!-- PARTICIPANTS -->
      <section id="participants-section">
        <h2>Participants</h2>

        <table class="participants-table">
          <thead>
            <tr>
              <th style="width:44px;">Seed</th>
              <th>Name</th>
              <th style="width:60px;text-align:right;">Actions</th>
            </tr>
          </thead>
          <tbody id="participants-body">
          </tbody>
        </table>

        <p class="helper-text">
          Seeding is based on row order. You can shuffle the list or manually edit names.
        </p>
      </section>

      <!-- BRACKET PREVIEW -->
      <section id="bracket-section">
        <h2>Bracket Preview</h2>
        <div class="bracket-shell">
          <div class="bracket-header">
            <div id="bracket-title">No bracket generated yet.</div>
            <div id="bracket-meta"></div>
          </div>
          <div id="bracket-container" class="bracket-container">
            <div class="empty-state">
              Add at least 2 participants and click <strong>Generate bracket</strong> to build your first tree.
            </div>
          </div>
        </div>
      </section>
    </main>
  </div>

  <!-- Supabase CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <script>
    // ===== Supabase Setup =====
    const SUPABASE_URL = 'https://fjdyppkanjnvyscqrfum.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZqZHlwcGthbmpudnlzY3FyZnVtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAzNDU1NzIsImV4cCI6MjA3NTkyMTU3Mn0.ssEN7uA9BVm9AkhsjkWxhPzV1-VQVxc4-u7LS2wt4Aw';

    const client = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // ------- STATE -------
    const state = {
      participants: [],        // [{id, name}]
      bracketParticipants: [], // includes BYEs (if any)
      rounds: [],              // [ [matches...] ]
      matchById: {},           // id -> match
      matchCounter: 0,
      settings: {
        name: 'My Tournament',
        format: 'single',
        bestOf: 3,
        seedingMode: 'seeded',
        thirdPlace: false,
        totalRounds: null,
        bracketSize: null,
        byes: null,
        stages: []             // [{ name, qualifiers }]
      },
      lastSavedId: null
    };

    const participantsBody   = document.getElementById('participants-body');
    const addBtn             = document.getElementById('add-participant-btn');
    const shuffleBtn         = document.getElementById('shuffle-btn');
    const clearBtn           = document.getElementById('clear-btn');
    const generateBtn        = document.getElementById('generate-btn');
    const saveBtn            = document.getElementById('save-btn');
    const nameInput          = document.getElementById('tournament-name');
    const formatSelect       = document.getElementById('tournament-format');
    const bestOfSelect       = document.getElementById('best-of');
    const seedingSelect      = document.getElementById('seeding-mode');
    const thirdPlaceToggle   = document.getElementById('third-place-toggle');
    const bracketContainer   = document.getElementById('bracket-container');
    const bracketTitle       = document.getElementById('bracket-title');
    const bracketMeta        = document.getElementById('bracket-meta');
    const saveStatus         = document.getElementById('save-status');
    const saveStatusPill     = document.getElementById('save-status-pill');
    const tournamentSelect   = document.getElementById('tournament-select');
    const bracketMath        = document.getElementById('bracket-math');

    // NEW: stage elements
    const stagesContainer    = document.getElementById('stages-container');
    const addStageBtn        = document.getElementById('add-stage-btn');

    let nextParticipantId = 1;

    // ------- UTILITIES -------
    function createParticipant(name){
      return {
        id: 'p' + (nextParticipantId++),
        name: name || ('Player ' + (state.participants.length + 1))
      };
    }

    function syncSettingsFromUI(){
      state.settings.name        = nameInput.value.trim() || 'My Tournament';
      state.settings.format      = formatSelect.value;
      state.settings.bestOf      = parseInt(bestOfSelect.value,10) || 1;
      state.settings.seedingMode = seedingSelect.value;
      state.settings.thirdPlace  = thirdPlaceToggle.checked;
      // stages are edited live via renderStages()/events
    }

    function shuffleArray(arr){
      for(let i = arr.length-1; i > 0; i--){
        const j = Math.floor(Math.random() * (i+1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    function getBracketIdFromURL(){
      const params = new URLSearchParams(window.location.search);
      const id = params.get('id');
      return id ? parseInt(id,10) : null;
    }

    // Ensure stages array exists & has at least one stage
    function ensureDefaultStages(){
      if(!state.settings.stages || !Array.isArray(state.settings.stages)){
        state.settings.stages = [];
      }
      if(state.settings.stages.length === 0){
        state.settings.stages.push({
          name: 'Main Stage',
          qualifiers: 1
        });
      }
    }

    function renderStages(){
      if(!stagesContainer) return;
      ensureDefaultStages();
      stagesContainer.innerHTML = '';
      const stages = state.settings.stages;

      stages.forEach((st, idx) => {
        const row = document.createElement('div');
        row.className = 'stage-row';

        const idxSpan = document.createElement('span');
        idxSpan.className = 'stage-index';
        idxSpan.textContent = `Stage ${idx + 1}`;
        row.appendChild(idxSpan);

        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.className = 'stage-name';
        nameInput.placeholder = `Stage ${idx + 1} name`;
        nameInput.value = st.name || '';
        nameInput.addEventListener('input', () => {
          st.name = nameInput.value;
          renderSaveStatus(true);
        });
        row.appendChild(nameInput);

        const qualInput = document.createElement('input');
        qualInput.type = 'number';
        qualInput.min = '1';
        qualInput.className = 'stage-qualifiers';
        qualInput.value =
          (typeof st.qualifiers === 'number' && st.qualifiers > 0)
            ? st.qualifiers
            : 1;
        qualInput.addEventListener('input', () => {
          const val = parseInt(qualInput.value, 10);
          st.qualifiers = Number.isNaN(val) || val < 1 ? 1 : val;
          qualInput.value = st.qualifiers;
          renderSaveStatus(true);
        });
        row.appendChild(qualInput);

        const note = document.createElement('small');
        note.className = 'stage-qualify';
        if(idx < stages.length - 1){
          note.textContent = 'qualify to next stage';
        }else{
          note.textContent = 'final stage';
        }
        row.appendChild(note);

        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-stage';
        removeBtn.type = 'button';
        removeBtn.textContent = '‚úï';
        removeBtn.addEventListener('click', () => {
          stages.splice(idx, 1);
          renderStages();
          renderSaveStatus(true);
        });
        row.appendChild(removeBtn);

        stagesContainer.appendChild(row);
      });
    }

    if(addStageBtn){
      addStageBtn.addEventListener('click', () => {
        if(!state.settings.stages || !Array.isArray(state.settings.stages)){
          state.settings.stages = [];
        }
        const nextIndex = state.settings.stages.length + 1;
        state.settings.stages.push({
          name: `Stage ${nextIndex}`,
          qualifiers: 1
        });
        renderStages();
        renderSaveStatus(true);
      });
    }

    // Bracket math helper (for display + sanity check)
    function updateBracketMath(){
      if(!bracketMath) return;
      const n = state.participants.length;
      if(n < 2){
        bracketMath.textContent =
          'Add at least 2 participants to generate a single-elimination bracket.';
        return;
      }
      const rounds = Math.ceil(Math.log2(n));
      const bracketSize = 1 << rounds;
      const byes = bracketSize - n;
      bracketMath.textContent =
        `${n} participants ‚Üí ${rounds} rounds ‚Ä¢ bracket size ${bracketSize} ‚Ä¢ byes ${byes}`;
    }

    // ------- PARTICIPANTS UI -------
    function renderParticipants(){
      participantsBody.innerHTML = '';
      state.participants.forEach((p, idx) => {
        const tr = document.createElement('tr');

        const seedTd = document.createElement('td');
        seedTd.className = 'seed-cell';
        seedTd.textContent = idx + 1;
        tr.appendChild(seedTd);

        const nameTd = document.createElement('td');
        const input = document.createElement('input');
        input.type = 'text';
        input.value = p.name;
        input.addEventListener('input', () => {
          p.name = input.value;
          renderSaveStatus(true);
          updateBracketMath();
        });
        nameTd.appendChild(input);
        tr.appendChild(nameTd);

        const actionsTd = document.createElement('td');
        actionsTd.style.textAlign = 'right';

        const removeBtn = document.createElement('button');
        removeBtn.textContent = '‚úï';
        removeBtn.style.padding = '3px 6px';
        removeBtn.style.fontSize = '.7rem';
        removeBtn.addEventListener('click', () => {
          state.participants.splice(idx, 1);
          renderParticipants();
          renderSaveStatus(true);
          updateBracketMath();
        });
        actionsTd.appendChild(removeBtn);
        tr.appendChild(actionsTd);

        participantsBody.appendChild(tr);
      });

      updateBracketMath();
    }

    addBtn.addEventListener('click', () => {
      state.participants.push(createParticipant());
      renderParticipants();
      renderSaveStatus(true);
    });

    shuffleBtn.addEventListener('click', () => {
      shuffleArray(state.participants);
      renderParticipants();
      renderSaveStatus(true);
    });

    clearBtn.addEventListener('click', () => {
      if(!confirm('Clear all participants and bracket?')) return;
      state.participants = [];
      state.rounds = [];
      state.matchById = {};
      state.matchCounter = 0;
      state.bracketParticipants = [];
      renderParticipants();
      renderEmptyBracket();
      state.lastSavedId = null;
      renderSaveStatus(true);
    });

    // ------- BRACKET GENERATION (SINGLE ELIM) -------
    function generateBracket(){
      syncSettingsFromUI();

      const n = state.participants.length;
      if(n < 2){
        alert('You need at least 2 participants to generate a bracket.');
        return;
      }

      // Build seeded list based on seeding mode
      let seeded = state.participants.map((p, idx) => ({
        id: p.id,
        name: p.name || ('Player ' + (idx+1)),
        isBye: false
      }));

      if(state.settings.seedingMode === 'random'){
        shuffleArray(seeded);
      }
      // "seeded" and "list" both use current order

      // ---- Automatic rounds / bracket size / byes ----
      const roundsCount = Math.ceil(Math.log2(n));    // minimal rounds
      const bracketSize = 1 << roundsCount;           // 2^rounds
      const byesNeeded  = bracketSize - n;            // minimal number of BYEs needed

      state.settings.totalRounds = roundsCount;
      state.settings.bracketSize = bracketSize;
      state.settings.byes        = byesNeeded;

      // Assign BYEs to the tail so they pair with top seeds (1 vs last, 2 vs second last...)
      const seededWithByes = seeded.slice();
      for(let i=0; i<byesNeeded; i++){
        seededWithByes.push({
          id:'bye-'+i,
          name:'BYE',
          isBye:true
        });
      }

      state.bracketParticipants = seededWithByes;
      state.rounds = [];
      state.matchById = {};
      state.matchCounter = 0;

      // Create rounds
      for(let r=0; r<roundsCount; r++){
        state.rounds.push([]);
      }

      // Round 1: pair 1 vs last, 2 vs second last, etc.
      const round1 = state.rounds[0];
      const half = bracketSize / 2;
      for(let i=0;i<half;i++){
        const p1 = seededWithByes[i] || null;
        const p2 = seededWithByes[bracketSize - 1 - i] || null;
        const match = createMatch(1, i, p1, p2);
        round1.push(match);
      }

      // Subsequent rounds: empty matches, link from previous
      let prevRoundMatches = round1;
      for(let r=2;r<=roundsCount;r++){
        const prevCount = prevRoundMatches.length;
        const curCount = prevCount / 2;
        const curRound = [];
        for(let i=0;i<curCount;i++){
          const match = createMatch(r, i, null, null);
          curRound.push(match);
        }
        state.rounds[r-1] = curRound;

        // Link previous -> next
        prevRoundMatches.forEach((m, idx) => {
          const toIndex = Math.floor(idx / 2);
          const slot = (idx % 2 === 0) ? 1 : 2;
          m.nextMatchId = curRound[toIndex].id;
          m.nextMatchSlot = slot;
        });

        prevRoundMatches = curRound;
      }

      // Auto-advance matches that are effectively BYE for one participant
      for(const m of state.rounds[0]){
        if(m.p1 && m.p1.isBye && m.p2 && !m.p2.isBye){
          m.winnerId = m.p2.id;
          propagateWinner(m);
        }else if(m.p2 && m.p2.isBye && m.p1 && !m.p1.isBye){
          m.winnerId = m.p1.id;
          propagateWinner(m);
        }
      }

      renderBracket();
      renderSaveStatus(true); // bracket changed, unsaved
      updateBracketMath();
    }

    function createMatch(roundNumber, indexInRound, p1, p2){
      const id = 'm' + (++state.matchCounter);
      const match = {
        id,
        round: roundNumber,
        index: indexInRound,
        p1,
        p2,
        s1: 0,
        s2: 0,
        winnerId: null,
        nextMatchId: null,
        nextMatchSlot: null
      };
      state.matchById[id] = match;
      return match;
    }

    function findParticipantById(id){
      return state.bracketParticipants.find(p => p.id === id) || null;
    }

    function propagateWinner(match){
      if(!match.nextMatchId || !match.winnerId) return;
      const winner = findParticipantById(match.winnerId);
      if(!winner) return;
      const nextMatch = state.matchById[match.nextMatchId];
      if(!nextMatch) return;

      if(match.nextMatchSlot === 1){
        nextMatch.p1 = winner;
      }else{
        nextMatch.p2 = winner;
      }
    }

    function clearAdvancement(match){
      if(!match.nextMatchId) return;
      const nextMatch = state.matchById[match.nextMatchId];
      if(!nextMatch) return;

      // Remove previously advanced participant from the appropriate slot
      let removedId = null;
      if(match.nextMatchSlot === 1){
        removedId = nextMatch.p1 ? nextMatch.p1.id : null;
        nextMatch.p1 = null;
      }else{
        removedId = nextMatch.p2 ? nextMatch.p2.id : null;
        nextMatch.p2 = null;
      }

      // If that participant was also registered as winner, reset and recurse
      if(nextMatch.winnerId && removedId && nextMatch.winnerId === removedId){
        nextMatch.winnerId = null;
        nextMatch.s1 = 0;
        nextMatch.s2 = 0;
        clearAdvancement(nextMatch);
      }
    }

    function setMatchResult(matchId, score1, score2){
      const m = state.matchById[matchId];
      if(!m) return;

      if(!m.p1 || !m.p2){
        alert('Both slots must have participants to report a result.');
        return;
      }

      const s1 = parseInt(score1,10);
      const s2 = parseInt(score2,10);
      if(Number.isNaN(s1) || Number.isNaN(s2)){
        alert('Please enter numeric scores for both players.');
        return;
      }
      if(s1 === s2){
        alert('Ties are not allowed in elimination. Adjust the scores.');
        return;
      }

      // Clear old advancement down the tree
      clearAdvancement(m);

      m.s1 = s1;
      m.s2 = s2;

      const winner = s1 > s2 ? m.p1 : m.p2;
      m.winnerId = winner.id;

      propagateWinner(m);
      renderBracket();
      renderSaveStatus(true); // unsaved change
    }

    // ------- BRACKET RENDER -------
    function renderEmptyBracket(){
      bracketTitle.textContent = 'No bracket generated yet.';
      bracketMeta.textContent = '';
      bracketContainer.innerHTML = '';
      const div = document.createElement('div');
      div.className = 'empty-state';
      div.innerHTML = 'Add participants on the left and click <strong>Generate bracket</strong> to see the tree.';
      bracketContainer.appendChild(div);
    }

    function renderBracket(){
      if(!state.rounds.length){
        renderEmptyBracket();
        return;
      }

      const n = state.participants.length;
      let roundsCount = state.settings.totalRounds;
      if(!roundsCount){
        roundsCount = Math.ceil(Math.log2(Math.max(n,2)));
      }
      let bracketSize = state.settings.bracketSize || (1 << roundsCount);
      let byes = (typeof state.settings.byes === 'number')
        ? state.settings.byes
        : (bracketSize - n);

      if(byes < 0) byes = 0;

      // Build stage summary
      let stageSummary = '';
      if(state.settings.stages && Array.isArray(state.settings.stages) && state.settings.stages.length){
        const parts = state.settings.stages.map((st, idx) => {
          const label =
            st.name && st.name.trim()
              ? st.name.trim()
              : `Stage ${idx + 1}`;
          if(idx < state.settings.stages.length - 1){
            const q =
              (typeof st.qualifiers === 'number' && st.qualifiers > 0)
                ? st.qualifiers
                : 'X';
            return `${label} (Top ${q} ‚Üí next)`;
          }
          return `${label} (Final)`;
        });
        stageSummary = ' ‚Ä¢ Stages: ' + parts.join(' ‚Üí ');
      }

      bracketTitle.textContent = state.settings.name || 'My Tournament';
      bracketMeta.textContent =
        `Format: Single Elimination ‚Ä¢ Best of ${state.settings.bestOf} ‚Ä¢ Players: ${n} ‚Ä¢ Rounds: ${roundsCount} ‚Ä¢ Byes: ${byes}` +
        stageSummary;

      bracketContainer.innerHTML = '';

      state.rounds.forEach((roundMatches, idx) => {
        const col = document.createElement('div');
        col.className = 'round-col';

        const title = document.createElement('div');
        title.className = 'round-title';

        if(idx === state.rounds.length-1){
          title.textContent = 'Finals';
        }else if(idx === state.rounds.length-2){
          title.textContent = 'Semi-finals';
        }else if(idx === 0){
          title.textContent = 'Round of ' + (roundMatches.length * 2);
        }else{
          title.textContent = 'Round ' + (idx+1);
        }
        col.appendChild(title);

        roundMatches.forEach(m => {
          const card = document.createElement('div');
          card.className = 'match-card';
          card.dataset.matchId = m.id;

          const metaRow = document.createElement('div');
          metaRow.className = 'match-meta';
          metaRow.innerHTML =
            `<span>Match ${m.id.toUpperCase()}</span><span class="badge">Bo${state.settings.bestOf}</span>`;
          card.appendChild(metaRow);

          const row1 = createPlayerRow(m, 1);
          const row2 = createPlayerRow(m, 2);
          card.appendChild(row1);
          card.appendChild(row2);

          const actions = document.createElement('div');
          actions.className = 'match-actions';

          const status = document.createElement('div');
          status.className = 'match-status';

          const isPureBye = (m.p1 && m.p1.isBye) && (m.p2 && m.p2.isBye);

          if(m.winnerId){
            const winner = findParticipantById(m.winnerId);
            status.innerHTML =
              `<span class="winner-tag">Winner:</span> ${winner ? winner.name : '‚Äî'}`;
          }else{
            if(isPureBye){
              status.innerHTML = `<span class="pending">Unused BYE slot</span>`;
            }else{
              status.innerHTML = `<span class="pending">Awaiting result‚Ä¶</span>`;
            }
          }

          const reportBtn = document.createElement('button');
          reportBtn.className = 'primary';
          reportBtn.textContent = 'Report score';

          if(isPureBye){
            reportBtn.disabled = true;
          }

          reportBtn.addEventListener('click', () => {
            const scoreInputs = card.querySelectorAll('.score-input');
            const s1 = scoreInputs[0].value;
            const s2 = scoreInputs[1].value;
            setMatchResult(m.id, s1, s2);
          });

          actions.appendChild(status);
          actions.appendChild(reportBtn);
          card.appendChild(actions);

          col.appendChild(card);
        });

        bracketContainer.appendChild(col);
      });
    }

    function createPlayerRow(match, slot){
      const row = document.createElement('div');
      row.className = 'player-row';

      const p = slot === 1 ? match.p1 : match.p2;
      let seedNumber = '‚Äî';

      // Seed here is simply the index in the participant list + 1
      if(p && !p.isBye){
        const seedIdx = state.participants.findIndex(pp => pp.id === p.id);
        if(seedIdx !== -1) seedNumber = seedIdx + 1;
      }

      const seedSpan = document.createElement('span');
      seedSpan.className = 'seed';
      seedSpan.textContent = seedNumber;

      const nameSpan = document.createElement('span');
      nameSpan.className = 'name';
      nameSpan.textContent = p ? p.name : 'TBD';

      if(p && p.isBye){
        row.classList.add('bye');
      }

      const scoreInput = document.createElement('input');
      scoreInput.type = 'number';
      scoreInput.min = '0';
      scoreInput.className = 'score-input';
      scoreInput.value = slot === 1 ? (match.s1 ?? 0) : (match.s2 ?? 0);

      row.appendChild(seedSpan);
      row.appendChild(nameSpan);
      row.appendChild(scoreInput);

      return row;
    }

    // ------- TOURNAMENT LOADING / SWITCHING -------
    function resetStateForNewTournament(){
      nextParticipantId = 1;
      state.participants = [];
      state.bracketParticipants = [];
      state.rounds = [];
      state.matchById = {};
      state.matchCounter = 0;
      state.settings = {
        name: 'My Tournament',
        format: 'single',
        bestOf: 3,
        seedingMode: 'seeded',
        thirdPlace: false,
        totalRounds: null,
        bracketSize: null,
        byes: null,
        stages: []
      };
      state.lastSavedId = null;

      // Optional: seed demo participants for quick testing
      const demoNames = [
        'Player 1','Player 2','Player 3','Player 4',
        'Player 5','Player 6','Player 7','Player 8'
      ];
      demoNames.forEach(n => state.participants.push(createParticipant(n)));

      // Update UI controls
      nameInput.value = state.settings.name;
      formatSelect.value = state.settings.format;
      bestOfSelect.value = String(state.settings.bestOf);
      seedingSelect.value = state.settings.seedingMode;
      thirdPlaceToggle.checked = state.settings.thirdPlace;

      ensureDefaultStages();
      renderStages();
      renderParticipants();
      renderEmptyBracket();
      renderSaveStatus(false);
      updateBracketMath();
    }

    async function loadTournamentList(){
      try{
        const { data, error } = await client
          .from('brackets')
          .select('id,name,created_at')
          .order('created_at', { ascending:false });

        tournamentSelect.innerHTML = '';

        // New tournament option
        const newOpt = document.createElement('option');
        newOpt.value = 'new';
        newOpt.textContent = '+ New tournament';
        tournamentSelect.appendChild(newOpt);

        if(error){
          console.error('Error loading tournament list:', error);
          tournamentSelect.value = 'new';
          resetStateForNewTournament();
          return;
        }

        if(!data || !data.length){
          tournamentSelect.value = 'new';
          resetStateForNewTournament();
          return;
        }

        data.forEach(row => {
          const opt = document.createElement('option');
          opt.value = String(row.id);
          const name = row.name || 'Untitled';
          const dt   = row.created_at ? new Date(row.created_at).toLocaleString() : '';
          opt.textContent = `#${row.id} ‚Äî ${name}${dt ? ' ‚Ä¢ ' + dt : ''}`;
          tournamentSelect.appendChild(opt);
        });

        const urlId = getBracketIdFromURL();
        let selectedVal;

        if(urlId && data.some(r => r.id === urlId)){
          selectedVal = String(urlId);
        }else{
          // default to latest saved
          selectedVal = String(data[0].id);
        }

        tournamentSelect.value = selectedVal;
        if(selectedVal === 'new'){
          resetStateForNewTournament();
        }else{
          await loadTournament(parseInt(selectedVal,10));
        }
      }catch(err){
        console.error('Unexpected error loading tournaments:', err);
        tournamentSelect.innerHTML = '<option value="new">+ New tournament</option>';
        tournamentSelect.value = 'new';
        resetStateForNewTournament();
      }
    }

    async function loadTournament(id){
      try{
        const { data, error } = await client
          .from('brackets')
          .select('*')
          .eq('id', id)
          .maybeSingle();

        if(error){
          console.error('Error loading bracket:', error);
          alert('Error loading bracket: ' + error.message);
          return;
        }
        if(!data){
          alert('Bracket not found.');
          return;
        }

        state.lastSavedId = data.id;
        state.settings = Object.assign({
          name: data.name || 'My Tournament',
          format: 'single',
          bestOf: 3,
          seedingMode: 'seeded',
          thirdPlace: false,
          totalRounds: null,
          bracketSize: null,
          byes: null,
          stages: []
        }, data.settings || {});

        const d = data.data || {};
        state.participants        = d.participants || [];
        state.bracketParticipants = d.bracketParticipants || [];
        state.rounds              = d.rounds || [];

        ensureDefaultStages();
        renderStages();

        // Rebuild matchById and matchCounter
        state.matchById = {};
        state.matchCounter = 0;
        state.rounds.forEach(round => {
          round.forEach(m => {
            state.matchById[m.id] = m;
            const num = parseInt(String(m.id).replace('m',''),10);
            if(!Number.isNaN(num) && num > state.matchCounter){
              state.matchCounter = num;
            }
          });
        });

        // Update UI controls
        nameInput.value = state.settings.name || '';
        formatSelect.value = state.settings.format || 'single';
        bestOfSelect.value = String(state.settings.bestOf || 1);
        seedingSelect.value = state.settings.seedingMode || 'seeded';
        thirdPlaceToggle.checked = !!state.settings.thirdPlace;

        renderParticipants();
        if(state.rounds.length){
          renderBracket();
        }else{
          renderEmptyBracket();
        }
        renderSaveStatus(false);
        updateBracketMath();
      }catch(err){
        console.error('Unexpected error loading bracket:', err);
        alert('Unexpected error loading bracket.');
      }
    }

    if(tournamentSelect){
      tournamentSelect.addEventListener('change', () => {
        const val = tournamentSelect.value;
        if(val === 'new'){
          resetStateForNewTournament();
        }else{
          const id = parseInt(val,10);
          if(!Number.isNaN(id)){
            loadTournament(id);
          }
        }
      });
    }

    // ------- SAVE TO DATABASE -------
    function renderSaveStatus(dirty){
      if(dirty){
        saveStatus.textContent = 'Changes not yet saved to database.';
        saveStatusPill.textContent = 'Unsaved changes';
      }else if(state.lastSavedId){
        saveStatus.textContent =
          `Last saved as bracket #${state.lastSavedId}. Public page shows any saved bracket (or use ?id=${state.lastSavedId}).`;
        saveStatusPill.textContent = `Saved: #${state.lastSavedId}`;
      }else{
        saveStatus.textContent = 'Not yet saved to database.';
        saveStatusPill.textContent = 'Not saved to database';
      }
    }

    async function saveBracketToSupabase(){
      syncSettingsFromUI();

      if(!state.rounds.length){
        alert('Generate a bracket before saving to database.');
        return;
      }

      const payload = {
        name: state.settings.name,
        settings: state.settings,
        data: {
          participants: state.participants,
          bracketParticipants: state.bracketParticipants,
          rounds: state.rounds
        }
      };

      const isNew = !state.lastSavedId || (tournamentSelect && tournamentSelect.value === 'new');

      try{
        saveBtn.disabled = true;
        saveBtn.textContent = 'Saving...';
        renderSaveStatus(true);

        let data, error;

        if(isNew){
          ({ data, error } = await client
            .from('brackets')
            .insert(payload)
            .select('id, created_at')
            .single());
        }else{
          ({ data, error } = await client
            .from('brackets')
            .update(payload)
            .eq('id', state.lastSavedId)
            .select('id, created_at')
            .single());
        }

        if(error){
          console.error('database save error:', error);
          alert('Error saving bracket: ' + error.message);
          renderSaveStatus(true);
        }else{
          state.lastSavedId = data.id;
          await loadTournamentList(); // refresh dropdown + reload bracket from DB
          renderSaveStatus(false);
        }
      }catch(err){
        console.error('Network error while saving bracket:', err);
        alert('Error saving bracket: ' + (err.message || err));
        renderSaveStatus(true);
      }finally{
        saveBtn.disabled = false;
        saveBtn.textContent = 'Save bracket to database';
      }
    }

    saveBtn.addEventListener('click', saveBracketToSupabase);

    // ------- INIT -------
    function init(){
      renderEmptyBracket();
      ensureDefaultStages();
      renderStages();
      renderSaveStatus(false);
      generateBtn.addEventListener('click', generateBracket);
      loadTournamentList();
      updateBracketMath();
    }

    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
