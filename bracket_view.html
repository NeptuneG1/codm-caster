<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>Tournament Bracket — Public View</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

  <style>
    :root{
      --bg:#05060a;
      --panel:#111524;
      --panel2:#181d2f;
      --ink:#f6f7fb;
      --muted:#a3acc3;
      --brand:#ffe93b;
      --brand-soft:rgba(255,233,59,.14);
      --accent:#7fd2ff;
      --line:#262b3d;
      --radius-lg:16px;
      --radius-sm:8px;
    }

    *{box-sizing:border-box;margin:0;padding:0}
    html,body{
      height:100%;
      background:radial-gradient(circle at top,#171c30 0,#05060a 52%);
      color:var(--ink);
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"SF Pro Text",Segoe UI,Roboto,sans-serif;
    }

    body{
      display:flex;
      justify-content:center;
      padding:12px;
    }

    .app{
      width:100%;
      max-width:1280px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    header{
      padding:10px 16px;
      border-radius:var(--radius-lg);
      background:linear-gradient(135deg,#171c30,#111524);
      border:1px solid var(--line);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
    }
    header h1{
      font-size:1.05rem;
      letter-spacing:.04em;
      text-transform:uppercase;
    }
    header .meta{
      font-size:.75rem;
      color:var(--muted);
    }

    .header-right{
      display:flex;
      align-items:center;
      gap:6px;
    }

    header button{
      border:none;
      border-radius:999px;
      padding:6px 10px;
      font-size:.8rem;
      background:var(--panel2);
      color:var(--ink);
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:4px;
    }
    header button:hover{
      background:#20263a;
    }

    #tournament-select{
      background:var(--panel2);
      border-radius:999px;
      border:1px solid var(--line);
      color:var(--ink);
      padding:4px 8px;
      font-size:.78rem;
      max-width:260px;
      cursor:pointer;
    }
    #tournament-select:focus{
      outline:none;
      border-color:var(--accent);
      box-shadow:0 0 0 1px rgba(127,210,255,.3);
    }

    main{
      border-radius:var(--radius-lg);
      background:var(--panel);
      border:1px solid var(--line);
      padding:10px;
      min-height:0;
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    .bracket-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:.78rem;
      color:var(--muted);
    }

    .bracket-title{
      font-weight:600;
    }

    .bracket-container{
      display:flex;
      align-items:flex-start;
      gap:12px;
      overflow-x:auto;
      padding-bottom:4px;
      position:relative; /* for SVG overlay */
    }

    .round-col{
      min-width:180px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .round-title{
      font-size:.8rem;
      text-transform:uppercase;
      letter-spacing:.08em;
      color:var(--muted);
      margin-bottom:2px;
    }

    .match-card{
      background:var(--panel2);
      border-radius:var(--radius-sm);
      border:1px solid var(--line);
      padding:6px;
      display:flex;
      flex-direction:column;
      gap:4px;
      box-shadow:0 8px 12px rgba(0,0,0,.35);
      position:relative;
      z-index:2;
    }
    .match-meta{
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:.7rem;
      color:var(--muted);
    }
    .match-meta span.badge{
      padding:1px 6px;
      border-radius:999px;
      background:var(--brand-soft);
      color:var(--brand);
      font-weight:500;
      text-transform:uppercase;
      letter-spacing:.06em;
      font-size:.67rem;
    }

    .player-row{
      display:grid;
      grid-template-columns:22px minmax(0,1fr) 40px;
      align-items:center;
      gap:4px;
      font-size:.8rem;
    }
    .player-row span.seed{
      font-size:.7rem;
      color:var(--muted);
      text-align:right;
    }
    .player-row span.name{
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .player-row.bye span.name{
      color:var(--muted);
      opacity:.7;
      font-style:italic;
    }
    .player-row span.score{
      display:inline-block;
      text-align:center;
      border-radius:6px;
      padding:2px 0;
      font-size:.78rem;
      min-width:26px;
      background:#05060a;
      border:1px solid var(--line);
    }
    .player-row.winner span.name{
      color:var(--brand);
      font-weight:600;
    }
    .player-row.winner span.score{
      border-color:var(--brand);
    }

    .match-status{
      font-size:.7rem;
      color:var(--muted);
      margin-top:2px;
    }
    .match-status .winner-tag{
      color:var(--brand);
      font-weight:600;
    }
    .match-status .pending{
      color:var(--muted);
    }

    .empty-state{
      font-size:.8rem;
      color:var(--muted);
      padding:18px 10px;
      border-radius:var(--radius-sm);
      background:rgba(0,0,0,.14);
      border:1px dashed rgba(255,255,255,.08);
      text-align:center;
    }

    /* SVG connector layer */
    .bracket-lines{
      position:absolute;
      top:0;
      left:0;
      pointer-events:none;
      z-index:1;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <h1>Public Bracket View</h1>
        <div class="meta" id="header-meta">Loading tournaments…</div>
      </div>
      <div class="header-right">
        <select id="tournament-select">
          <option>Loading…</option>
        </select>
        <button id="refresh-btn">
          <span>⟳</span>
          <span>Refresh</span>
        </button>
      </div>
    </header>

    <main>
      <div class="bracket-header">
        <div class="bracket-title" id="bracket-title">—</div>
        <div id="bracket-meta"></div>
      </div>
      <div id="bracket-container" class="bracket-container">
        <div class="empty-state">
          Waiting for a bracket to be saved from the settings page…
        </div>
      </div>
    </main>
  </div>

  <!-- Supabase CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <script>
    const SUPABASE_URL = 'https://fjdyppkanjnvyscqrfum.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZqZHlwcGthbmpudnlzY3FyZnVtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAzNDU1NzIsImV4cCI6MjA3NTkyMTU3Mn0.ssEN7uA9BVm9AkhsjkWxhPzV1-VQVxc4-u7LS2wt4Aw';

    const client = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    const headerMeta       = document.getElementById('header-meta');
    const refreshBtn       = document.getElementById('refresh-btn');
    const bracketTitleEl   = document.getElementById('bracket-title');
    const bracketMetaEl    = document.getElementById('bracket-meta');
    const bracketContainer = document.getElementById('bracket-container');
    const tournamentSelect = document.getElementById('tournament-select');

    const state = {
      settings: null,
      participants: [],
      bracketParticipants: [],
      rounds: [],
      bracketId: null,
      tournaments: [],
      stageRanges: [] // for elimination formats
    };

    function getBracketIdFromURL(){
      const params = new URLSearchParams(window.location.search);
      const id = params.get('id');
      return id ? parseInt(id,10) : null;
    }

    // ---- Stage meta (same logic as settings page) ----
    function computeStageRoundMeta(bracketSize, stagesRaw){
      const stageRanges = [];
      if(!bracketSize || bracketSize < 2 || !Array.isArray(stagesRaw) || !stagesRaw.length){
        return { stageRanges, totalRoundsFromStages: null };
      }

      const stages = stagesRaw.map((s, idx) => ({
        name: s.name || ('Stage ' + (idx+1)),
        topX: (typeof s.topX === 'number' ? s.topX : 0)
      }));

      const lastIdx = stages.length - 1;
      if(!stages[lastIdx].topX || stages[lastIdx].topX <= 0){
        stages[lastIdx].topX = 1;
      }

      let remaining = bracketSize;
      let roundCursor = 1;
      let totalRoundsFromStages = 0;

      for(let i=0; i<stages.length; i++){
        let stage = stages[i];
        let target = stage.topX;

        if(target <= 0){
          continue;
        }

        target = Math.max(1, Math.min(target, remaining));

        if(remaining <= target){
          stageRanges.push({
            index: i,
            name: stage.name,
            startRound: roundCursor,
            endRound: roundCursor - 1,
            targetPlayers: remaining
          });
          continue;
        }

        const startRound = roundCursor;
        let roundsForStage = 0;

        while(remaining > target){
          remaining = remaining / 2;
          roundsForStage++;
          roundCursor++;
          totalRoundsFromStages++;
          if(totalRoundsFromStages > 32) break;
        }

        const endRound = roundCursor - 1;
        stageRanges.push({
          index: i,
          name: stage.name,
          startRound,
          endRound,
          targetPlayers: target
        });

        if(totalRoundsFromStages > 32) break;
      }

      return {
        stageRanges,
        totalRoundsFromStages: totalRoundsFromStages || null
      };
    }

    function getStageForRound(roundNumber){
      if(!state.stageRanges || !state.stageRanges.length) return null;
      for(const sr of state.stageRanges){
        if(roundNumber >= sr.startRound && roundNumber <= sr.endRound){
          return sr;
        }
      }
      return null;
    }

    // ---- Supabase loading ----
    async function loadTournamentList(){
      headerMeta.textContent = 'Loading tournaments…';
      tournamentSelect.innerHTML = '<option>Loading…</option>';

      try{
        const { data, error } = await client
          .from('brackets')
          .select('id,name,created_at')
          .order('created_at', { ascending:false });

        if(error){
          console.error('Error loading tournament list:', error);
          headerMeta.textContent = 'Error loading tournaments from database.';
          tournamentSelect.innerHTML = '<option value="">Error loading</option>';
          return;
        }

        state.tournaments = data || [];

        tournamentSelect.innerHTML = '';

        const latestOpt = document.createElement('option');
        latestOpt.value = 'latest';
        latestOpt.textContent = 'Latest saved';
        tournamentSelect.appendChild(latestOpt);

        state.tournaments.forEach(row => {
          const opt = document.createElement('option');
          opt.value = String(row.id);
          const name = row.name || 'Untitled';
          const dt = row.created_at ? new Date(row.created_at).toLocaleString() : '';
          opt.textContent = `#${row.id} — ${name}${dt ? ' • ' + dt : ''}`;
          tournamentSelect.appendChild(opt);
        });

        const urlId = getBracketIdFromURL();
        if(urlId && state.tournaments.some(t => t.id === urlId)){
          tournamentSelect.value = String(urlId);
        }else{
          tournamentSelect.value = 'latest';
        }

        headerMeta.textContent = 'Select a tournament or view the latest saved.';
        await loadBracket();
      }catch(err){
        console.error('Unexpected error loading tournaments:', err);
        headerMeta.textContent = 'Unexpected error loading tournaments.';
        tournamentSelect.innerHTML = '<option value="">Error</option>';
      }
    }

    async function loadBracket(explicitId){
      const urlId = getBracketIdFromURL();
      let idToLoad = explicitId ?? null;

      const selVal = tournamentSelect ? tournamentSelect.value : null;
      if(selVal && selVal !== 'latest'){
        idToLoad = parseInt(selVal,10);
      }else if(!explicitId && urlId){
        idToLoad = urlId;
      }

      headerMeta.textContent = 'Loading bracket from database…';
      bracketContainer.innerHTML = '<div class="empty-state">Loading bracket…</div>';

      try{
        let data, error;

        if(idToLoad){
          const res = await client
            .from('brackets')
            .select('*')
            .eq('id', idToLoad)
            .maybeSingle();
          data = res.data;
          error = res.error;
        }else{
          const res = await client
            .from('brackets')
            .select('*')
            .order('created_at', { ascending:false })
            .limit(1)
            .maybeSingle();
          data = res.data;
          error = res.error;
        }

        if(error){
          console.error('Error loading bracket:', error);
          headerMeta.textContent = 'Error loading bracket from database.';
          bracketContainer.innerHTML = '<div class="empty-state">Error loading bracket. Check console.</div>';
          bracketTitleEl.textContent = 'Error';
          bracketMetaEl.textContent = '';
          return;
        }

        if(!data){
          headerMeta.textContent = 'No brackets saved yet.';
          bracketContainer.innerHTML = '<div class="empty-state">No brackets found. Ask admin to save one from settings page.</div>';
          bracketTitleEl.textContent = 'No bracket';
          bracketMetaEl.textContent = '';
          return;
        }

        state.bracketId           = data.id;
        state.settings            = data.settings || {};
        const d                   = data.data || {};
        state.participants        = d.participants || [];
        state.bracketParticipants = d.bracketParticipants || [];
        state.rounds              = d.rounds || [];
        state.stageRanges         = [];

        if(tournamentSelect){
          const valStr = String(data.id);
          if(tournamentSelect.value !== valStr){
            const exists = [...tournamentSelect.options].some(o => o.value === valStr);
            if(exists){
              tournamentSelect.value = valStr;
            }
          }
        }

        const bracketName = state.settings.name || data.name || 'Tournament Bracket';
        headerMeta.textContent = `Showing #${data.id} — ${bracketName} • Updated ${new Date(data.created_at).toLocaleString()}`;
        renderBracket();
      }catch(err){
        console.error('Unexpected error loading bracket:', err);
        headerMeta.textContent = 'Unexpected error loading bracket.';
        bracketContainer.innerHTML = '<div class="empty-state">Unexpected error loading bracket.</div>';
        bracketTitleEl.textContent = 'Error';
        bracketMetaEl.textContent = '';
      }
    }

    // ---- Helpers ----
    function findParticipantById(id){
      return state.bracketParticipants.find(p => p.id === id) || null;
    }

    function createPlayerRow(match, slot){
      const row = document.createElement('div');
      row.className = 'player-row';

      const p = slot === 1 ? match.p1 : match.p2;
      let seedNumber = '—';

      if(p && !p.isBye){
        const seedIdx = state.participants.findIndex(pp => pp.id === p.id);
        if(seedIdx !== -1) seedNumber = seedIdx + 1;
      }

      const seedSpan = document.createElement('span');
      seedSpan.className = 'seed';
      seedSpan.textContent = seedNumber;

      const nameSpan = document.createElement('span');
      nameSpan.className = 'name';
      nameSpan.textContent = p ? p.name : 'TBD';

      if(p && p.isBye){
        row.classList.add('bye');
      }

      const scoreSpan = document.createElement('span');
      scoreSpan.className = 'score';
      const score = slot === 1 ? (match.s1 ?? 0) : (match.s2 ?? 0);
      scoreSpan.textContent = score;

      if(match.winnerId && p && !p.isBye && p.id === match.winnerId){
        row.classList.add('winner');
      }

      row.appendChild(seedSpan);
      row.appendChild(nameSpan);
      row.appendChild(scoreSpan);

      return row;
    }

    // ---- Draw SVG connectors for elimination formats ----
    function drawBracketLines(){
      const format = state.settings?.format || 'single';
      if(format !== 'single' && format !== 'double'){
        const existing = bracketContainer.querySelector('#bracket-lines');
        if(existing) existing.remove();
        return;
      }

      if(!state.rounds.length) return;

      let svg = bracketContainer.querySelector('#bracket-lines');
      if(!svg){
        svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('id','bracket-lines');
        svg.classList.add('bracket-lines');
        bracketContainer.prepend(svg);
      }

      while(svg.firstChild){
        svg.removeChild(svg.firstChild);
      }

      const containerRect = bracketContainer.getBoundingClientRect();
      svg.setAttribute('width', bracketContainer.scrollWidth);
      svg.setAttribute('height', bracketContainer.scrollHeight);

      for(let rIdx = 1; rIdx < state.rounds.length; rIdx++){
        const roundMatches = state.rounds[rIdx];
        const prevRound = state.rounds[rIdx - 1];

        roundMatches.forEach((match, mIdx) => {
          const parentCard = bracketContainer.querySelector(
            `.match-card[data-match-id="${match.id}"]`
          );
          if(!parentCard) return;

          const parentRect = parentCard.getBoundingClientRect();
          const parentX = parentRect.left - containerRect.left;
          const parentY = (parentRect.top + parentRect.bottom) / 2 - containerRect.top;

          const childA = prevRound[mIdx*2];
          const childB = prevRound[mIdx*2 + 1];
          const children = [childA, childB];

          children.forEach(child => {
            if(!child) return;
            const childCard = bracketContainer.querySelector(
              `.match-card[data-match-id="${child.id}"]`
            );
            if(!childCard) return;

            const childRect = childCard.getBoundingClientRect();
            const childX = childRect.right - containerRect.left;
            const childY = (childRect.top + childRect.bottom) / 2 - containerRect.top;

            const midX = (childX + parentX) / 2;

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const d = [
              `M ${childX} ${childY}`,
              `L ${midX} ${childY}`,
              `L ${midX} ${parentY}`,
              `L ${parentX} ${parentY}`
            ].join(' ');
            path.setAttribute('d', d);
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke', 'rgba(255,255,255,0.22)');
            path.setAttribute('stroke-width', '1.5');
            path.setAttribute('stroke-linecap', 'round');
            svg.appendChild(path);
          });
        });
      }
    }

    // ---- Main render ----
    function renderBracket(){
      if(!state.rounds.length){
        bracketTitleEl.textContent = state.settings?.name || 'No bracket';
        bracketMetaEl.textContent  = '';
        bracketContainer.innerHTML = '<div class="empty-state">Bracket has no rounds yet.</div>';
        const existing = bracketContainer.querySelector('#bracket-lines');
        if(existing) existing.remove();
        return;
      }

      const n = state.participants.length;
      const settings = state.settings || {};
      const format = settings.format || 'single';
      const bestOf = Number(settings.bestOf || 1);

      const formatLabels = {
        single: 'Single Elimination',
        double: 'Double Elimination',
        roundrobin: 'Round Robin',
        swiss: 'Swiss'
      };
      const formatLabel = formatLabels[format] || 'Unknown';

      bracketTitleEl.textContent = settings.name || 'Tournament Bracket';

      if(format === 'single' || format === 'double'){
        let roundsCount = settings.totalRounds || state.rounds.length || Math.ceil(Math.log2(Math.max(n,2)));
        let bracketSize = settings.bracketSize || (1 << roundsCount);
        let byes = (typeof settings.byes === 'number') ? settings.byes : (bracketSize - n);
        if(byes < 0) byes = 0;

        const stageMeta = computeStageRoundMeta(bracketSize, settings.stages || []);
        state.stageRanges = stageMeta.stageRanges || [];

        bracketMetaEl.textContent =
          `Format: ${formatLabel} • Best of ${bestOf} • Round of ${bracketSize} • Players: ${n} • Rounds: ${roundsCount} • Byes: ${byes}`;
      }else{
        state.stageRanges = [];
        let matchesTotal = 0;
        state.rounds.forEach(r => matchesTotal += r.length);
        bracketMetaEl.textContent =
          `Format: ${formatLabel} • Best of ${bestOf} • Players: ${n} • Rounds: ${state.rounds.length} • Matches: ${matchesTotal}`;
      }

      bracketContainer.innerHTML = '';

      state.rounds.forEach((roundMatches, idx) => {
        const roundNumber = idx + 1;

        const col = document.createElement('div');
        col.className = 'round-col';

        const title = document.createElement('div');
        title.className = 'round-title';

        const matchesCount = roundMatches.length;
        const matchesLabel = matchesCount === 1 ? '1 match' : `${matchesCount} matches`;

        let titleText;

        if(format === 'single' || format === 'double'){
          const stageInfo = getStageForRound(roundNumber);
          if(stageInfo){
            const originalStage = (settings.stages || [])[stageInfo.index];
            const stageName = (originalStage && originalStage.name) || stageInfo.name || ('Stage ' + (stageInfo.index+1));
            const tags = [stageName];

            if(stageInfo.startRound === roundNumber){
              tags.push('start');
            }
            if(stageInfo.endRound === roundNumber){
              const targetLabel = stageInfo.targetPlayers === 1
                ? 'end → champion'
                : `end → top ${stageInfo.targetPlayers}`;
              tags.push(targetLabel);
            }

            titleText = `Round ${roundNumber} (${matchesLabel}) • ${tags.join(' | ')}`;
          }else{
            titleText = `Round ${roundNumber} (${matchesLabel})`;
          }
        }else{
          titleText = `Round ${roundNumber} (${matchesLabel})`;
        }

        title.textContent = titleText;
        col.appendChild(title);

        roundMatches.forEach(m => {
          const card = document.createElement('div');
          card.className = 'match-card';
          card.dataset.matchId = m.id;

          const metaRow = document.createElement('div');
          metaRow.className = 'match-meta';
          metaRow.innerHTML = `<span>${String(m.id).toUpperCase()}</span><span class="badge">Bo${bestOf}</span>`;
          card.appendChild(metaRow);

          const row1 = createPlayerRow(m, 1);
          const row2 = createPlayerRow(m, 2);
          card.appendChild(row1);
          card.appendChild(row2);

          const status = document.createElement('div');
          status.className = 'match-status';

          if(m.winnerId){
            const winner = findParticipantById(m.winnerId);
            status.innerHTML = `<span class="winner-tag">Winner:</span> ${winner ? winner.name : '—'}`;
          }else if( (m.p1 && m.p1.isBye) && (m.p2 && m.p2.isBye) ){
            status.innerHTML = `<span class="pending">Unused BYE slot</span>`;
          }else{
            status.innerHTML = `<span class="pending">Pending result…</span>`;
          }

          card.appendChild(status);
          col.appendChild(card);
        });

        bracketContainer.appendChild(col);
      });

      drawBracketLines();
    }

    // ---- Events ----
    refreshBtn.addEventListener('click', () => loadBracket());
    tournamentSelect.addEventListener('change', () => loadBracket());

    window.addEventListener('resize', () => {
      if(state.rounds && state.rounds.length){
        drawBracketLines();
      }
    });

    document.addEventListener('DOMContentLoaded', () => {
      loadTournamentList();
    });
  </script>
</body>
</html>
