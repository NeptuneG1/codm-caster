<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>Tournament Bracket — Public View</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

  <style>
    :root{
      --bg:#05060a;
      --panel:#111524;
      --panel2:#181d2f;
      --ink:#f6f7fb;
      --muted:#a3acc3;
      --brand:#ffe93b;
      --brand-soft:rgba(255,233,59,.14);
      --accent:#7fd2ff;
      --line:#262b3d;
      --radius-lg:16px;
      --radius-sm:8px;
    }

    *{box-sizing:border-box;margin:0;padding:0}
    html,body{
      height:100%;
      background:radial-gradient(circle at top,#171c30 0,#05060a 52%);
      color:var(--ink);
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"SF Pro Text",Segoe UI,Roboto,sans-serif;
    }

    body{
      display:flex;
      justify-content:center;
      padding:12px;
    }

    .app{
      width:100%;
      max-width:1280px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    header{
      padding:10px 16px;
      border-radius:var(--radius-lg);
      background:linear-gradient(135deg,#171c30,#111524);
      border:1px solid var(--line);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
    }
    header h1{
      font-size:1.05rem;
      letter-spacing:.04em;
      text-transform:uppercase;
    }
    header .meta{
      font-size:.75rem;
      color:var(--muted);
    }

    .header-right{
      display:flex;
      align-items:center;
      gap:6px;
      flex-wrap:wrap;
    }

    header button{
      border:none;
      border-radius:999px;
      padding:6px 10px;
      font-size:.8rem;
      background:var(--panel2);
      color:var(--ink);
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:4px;
      transition:background .15s,transform .05s,box-shadow .15s;
    }
    header button:hover{
      background:#20263a;
      transform:translateY(-1px);
    }
    header button:active{
      transform:translateY(0);
      box-shadow:none;
    }

    #tournament-select{
      background:var(--panel2);
      border-radius:999px;
      border:1px solid var(--line);
      color:var(--ink);
      padding:4px 8px;
      font-size:.78rem;
      max-width:260px;
      cursor:pointer;
    }
    #tournament-select:focus{
      outline:none;
      border-color:var(--accent);
      box-shadow:0 0 0 1px rgba(127,210,255,.3);
    }

    main{
      border-radius:var(--radius-lg);
      background:var(--panel);
      border:1px solid var(--line);
      padding:10px;
      min-height:0;
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    .bracket-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:.78rem;
      color:var(--muted);
    }

    .bracket-title{
      font-weight:600;
    }

    .bracket-container{
      display:flex;
      align-items:flex-start;
      gap:12px;
      overflow-x:auto;
      padding-bottom:4px;
    }

    .round-col{
      flex:0 0 250px;          /* fixed flex-basis */
      width:250px;             /* explicit width */
      max-width:250px;         /* prevent stretching */
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .round-title{
      font-size:.8rem;
      text-transform:uppercase;
      letter-spacing:.08em;
      color:var(--muted);
      margin-bottom:4px;
      white-space:normal;              /* allow wrapping */
      overflow-wrap:break-word;        /* wrap long titles */
      word-break:break-word;           /* extra safety */
    }

    .match-card{
      background:var(--panel2);
      border-radius:var(--radius-sm);
      border:1px solid var(--line);
      padding:6px;
      display:flex;
      flex-direction:column;
      gap:4px;
      box-shadow:0 8px 12px rgba(0,0,0,.35);
      position:relative;
      width:100%;              /* NEW: fill round column */
    }
    .match-meta{
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:.7rem;
      color:var(--muted);
    }
    .match-meta span.badge{
      padding:1px 6px;
      border-radius:999px;
      background:var(--brand-soft);
      color:var(--brand);
      font-weight:500;
      text-transform:uppercase;
      letter-spacing:.06em;
      font-size:.67rem;
    }

    .player-row{
      display:grid;
      grid-template-columns:22px minmax(0,1fr) 40px;
      align-items:flex-start;          /* better for multi-line names */
      gap:4px;
      font-size:.8rem;
    }
    .player-row span.seed{
      font-size:.7rem;
      color:var(--muted);
      text-align:right;
    }
    .player-row span.name{
      white-space:normal;              /* allow wrapping */
      overflow-wrap:break-word;        /* wrap long words / tags */
      word-break:break-word;           /* extra safety */
    }
    .player-row.bye span.name{
      color:var(--muted);
      opacity:.7;
      font-style:italic;
    }
    .player-row span.score{
      display:inline-block;
      text-align:center;
      border-radius:6px;
      padding:2px 0;
      font-size:.78rem;
      min-width:26px;
      background:#05060a;
      border:1px solid var(--line);
    }
    .player-row.winner span.name{
      color:var(--brand);
      font-weight:600;
    }
    .player-row.winner span.score{
      border-color:var(--brand);
    }

    .match-status{
      font-size:.7rem;
      color:var(--muted);
      margin-top:2px;
    }
    .match-status .winner-tag{
      color:var(--brand);
      font-weight:600;
    }
    .match-status .pending{
      color:var(--muted);
    }

    .empty-state{
      font-size:.8rem;
      color:var(--muted);
      padding:18px 10px;
      border-radius:var(--radius-sm);
      background:rgba(0,0,0,.14);
      border:1px dashed rgba(255,255,255,.08);
      text-align:center;
      width:100%;
    }

    @media(max-width:768px){
      header{
        flex-direction:column;
        align-items:flex-start;
      }
      .bracket-header{
        flex-direction:column;
        align-items:flex-start;
        gap:4px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <h1>Public Bracket View</h1>
        <div class="meta" id="header-meta">Loading tournaments…</div>
      </div>
      <div class="header-right">
        <select id="tournament-select">
          <option>Loading…</option>
        </select>
        <button id="refresh-btn">
          <span>⟳</span>
          <span>Refresh</span>
        </button>
      </div>
    </header>

    <main>
      <div class="bracket-header">
        <div class="bracket-title" id="bracket-title">—</div>
        <div id="bracket-meta"></div>
      </div>
      <div id="bracket-container" class="bracket-container">
        <div class="empty-state">
          Waiting for a bracket to be saved from the settings page…
        </div>
      </div>
    </main>
  </div>

  <!-- Supabase CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <script>
    // ===== Supabase Setup =====
    const SUPABASE_URL = 'https://fjdyppkanjnvyscqrfum.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZqZHlwcGthbmpudnlzY3FyZnVtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAzNDU1NzIsImV4cCI6MjA3NTkyMTU3Mn0.ssEN7uA9BVm9AkhsjkWxhPzV1-VQVxc4-u7LS2wt4Aw';

    const client = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    const headerMeta       = document.getElementById('header-meta');
    const refreshBtn       = document.getElementById('refresh-btn');
    const bracketTitleEl   = document.getElementById('bracket-title');
    const bracketMetaEl    = document.getElementById('bracket-meta');
    const bracketContainer = document.getElementById('bracket-container');
    const tournamentSelect = document.getElementById('tournament-select');

    const state = {
      settings: null,
      participants: [],
      bracketParticipants: [],
      rounds: [],
      bracketId: null,
      tournaments: [],
      stageRanges: []
    };

    // ===== URL Helpers =====
    function getBracketIdFromURL(){
      const params = new URLSearchParams(window.location.search);
      const id = params.get('id');
      return id ? parseInt(id,10) : null;
    }

    function updateUrlFromSelection(){
      if(!tournamentSelect) return;
      const val = tournamentSelect.value;
      const url = new URL(window.location.href);

      if(val === 'latest' || !val){
        url.searchParams.delete('id');
      }else{
        url.searchParams.set('id', val);
      }
      window.history.replaceState(null, '', url.toString());
    }

    // ===== Stage meta (same logic as settings) =====
    function computeStageRoundMeta(bracketSize, stagesRaw){
      const stageRanges = [];
      if(!bracketSize || bracketSize < 2 || !Array.isArray(stagesRaw) || !stagesRaw.length){
        return { stageRanges, totalRoundsFromStages: null };
      }

      const stages = stagesRaw.map((s, idx) => ({
        name: s.name || ('Stage ' + (idx+1)),
        topX: (typeof s.topX === 'number' ? s.topX : 0)
      }));

      // Ensure last stage ends in champion if blank
      const lastIdx = stages.length - 1;
      if(!stages[lastIdx].topX || stages[lastIdx].topX <= 0){
        stages[lastIdx].topX = 1;
      }

      let remaining = bracketSize;
      let roundCursor = 1;
      let totalRoundsFromStages = 0;

      for(let i=0;i<stages.length;i++){
        let stage = stages[i];
        let target = stage.topX;

        if(target <= 0) continue;

        target = Math.max(1, Math.min(target, remaining));

        if(remaining <= target){
          stageRanges.push({
            index: i,
            name: stage.name,
            startRound: roundCursor,
            endRound: roundCursor - 1,
            targetPlayers: remaining
          });
          continue;
        }

        const startRound = roundCursor;
        let roundsForStage = 0;

        while(remaining > target){
          remaining = remaining / 2;
          roundsForStage++;
          roundCursor++;
          totalRoundsFromStages++;
          if(totalRoundsFromStages > 32) break;
        }

        const endRound = roundCursor - 1;
        stageRanges.push({
          index: i,
          name: stage.name,
          startRound,
          endRound,
          targetPlayers: target
        });

        if(totalRoundsFromStages > 32) break;
      }

      return {
        stageRanges,
        totalRoundsFromStages: totalRoundsFromStages || null
      };
    }

    function getStageForRound(stageRanges, roundNumber){
      if(!stageRanges || !stageRanges.length) return null;
      for(const sr of stageRanges){
        if(roundNumber >= sr.startRound && roundNumber <= sr.endRound){
          return sr;
        }
      }
      return null;
    }

    // ===== Load list of tournaments =====
    async function loadTournamentList(){
      headerMeta.textContent = 'Loading tournaments…';
      tournamentSelect.innerHTML = '<option>Loading…</option>';

      try{
        const { data, error } = await client
          .from('brackets')
          .select('id,name,created_at')
          .order('created_at', { ascending:false });

        if(error){
          console.error('Error loading tournament list:', error);
          headerMeta.textContent = 'Error loading tournaments from database.';
          tournamentSelect.innerHTML = '<option value="">Error loading</option>';
          return;
        }

        state.tournaments = data || [];
        tournamentSelect.innerHTML = '';

        const latestOpt = document.createElement('option');
        latestOpt.value = 'latest';
        latestOpt.textContent = 'Latest saved';
        tournamentSelect.appendChild(latestOpt);

        state.tournaments.forEach(row => {
          const opt = document.createElement('option');
          opt.value = String(row.id);
          const name = row.name || 'Untitled';
          const dt   = row.created_at ? new Date(row.created_at).toLocaleString() : '';
          opt.textContent = `#${row.id} — ${name}${dt ? ' • ' + dt : ''}`;
          tournamentSelect.appendChild(opt);
        });

        const urlId = getBracketIdFromURL();
        if(urlId && state.tournaments.some(t => t.id === urlId)){
          tournamentSelect.value = String(urlId);
        }else{
          tournamentSelect.value = 'latest';
        }

        updateUrlFromSelection();
        headerMeta.textContent = 'Select a tournament or view the latest saved.';
        await loadBracket();  // load based on current selection / URL
      }catch(err){
        console.error('Unexpected error loading tournaments:', err);
        headerMeta.textContent = 'Unexpected error loading tournaments.';
        tournamentSelect.innerHTML = '<option value="">Error</option>';
      }
    }

    // ===== Load a specific bracket =====
    async function loadBracket(explicitId){
      const urlId = getBracketIdFromURL();
      let idToLoad = explicitId ?? null;

      const selVal = tournamentSelect ? tournamentSelect.value : null;
      if(selVal && selVal !== 'latest'){
        idToLoad = parseInt(selVal,10);
      }else if(!explicitId && urlId){
        idToLoad = urlId;
      }

      headerMeta.textContent = 'Loading bracket from database…';
      bracketContainer.innerHTML = '<div class="empty-state">Loading bracket…</div>';

      try{
        let data, error;

        if(idToLoad){
          const res = await client
            .from('brackets')
            .select('*')
            .eq('id', idToLoad)
            .maybeSingle();
          data = res.data;
          error = res.error;
        }else{
          const res = await client
            .from('brackets')
            .select('*')
            .order('created_at', { ascending:false })
            .limit(1)
            .maybeSingle();
          data = res.data;
          error = res.error;
        }

        if(error){
          console.error('Error loading bracket:', error);
          headerMeta.textContent = 'Error loading bracket from database.';
          bracketContainer.innerHTML = '<div class="empty-state">Error loading bracket. Check console.</div>';
          bracketTitleEl.textContent = 'Error';
          bracketMetaEl.textContent = '';
          return;
        }

        if(!data){
          headerMeta.textContent = 'No brackets saved yet.';
          bracketContainer.innerHTML = '<div class="empty-state">No brackets found. Ask admin to save one from settings page.</div>';
          bracketTitleEl.textContent = 'No bracket';
          bracketMetaEl.textContent = '';
          return;
        }

        state.bracketId           = data.id;
        state.settings            = data.settings || {};
        const d                   = data.data || {};
        state.participants        = d.participants || [];
        state.bracketParticipants = d.bracketParticipants || [];
        state.rounds              = d.rounds || [];
        state.stageRanges         = [];

        const bracketName = state.settings.name || data.name || 'Tournament Bracket';
        headerMeta.textContent = `Showing #${data.id} — ${bracketName} • Updated ${new Date(data.created_at).toLocaleString()}`;

        // Sync dropdown to loaded id
        if(tournamentSelect){
          const valStr = String(data.id);
          if(tournamentSelect.value !== valStr){
            const exists = [...tournamentSelect.options].some(o => o.value === valStr);
            tournamentSelect.value = exists ? valStr : 'latest';
            updateUrlFromSelection();
          }
        }

        renderBracket();
      }catch(err){
        console.error('Unexpected error loading bracket:', err);
        headerMeta.textContent = 'Unexpected error loading bracket.';
        bracketContainer.innerHTML = '<div class="empty-state">Unexpected error loading bracket.</div>';
        bracketTitleEl.textContent = 'Error';
        bracketMetaEl.textContent = '';
      }
    }

    // ===== Helpers =====
    function findParticipantById(id){
      return state.bracketParticipants.find(p => p.id === id) || null;
    }

    function formatLabelFromSettings(){
      const fmt = (state.settings && state.settings.format) || 'single';
      const map = {
        single: 'Single Elimination',
        double: 'Double Elimination',
        roundrobin: 'Round Robin',
        swiss: 'Swiss'
      };
      return map[fmt] || 'Bracket';
    }

    // ===== Render Bracket =====
    function renderBracket(){
      const settings = state.settings || {};
      const rounds   = state.rounds || [];
      const participants = state.participants || [];

      if(!rounds.length){
        bracketTitleEl.textContent = settings.name || 'No bracket';
        bracketMetaEl.textContent  = '';
        bracketContainer.innerHTML = '<div class="empty-state">Bracket has no rounds yet.</div>';
        return;
      }

      const firstRoundMatches = rounds[0]?.length || 0;
      const storedBracketSize = settings.bracketSize;
      const bracketSize = (typeof storedBracketSize === 'number' && storedBracketSize > 0)
        ? storedBracketSize
        : Math.max(2, firstRoundMatches * 2);

      let byes = (typeof settings.byes === 'number') ? settings.byes : (bracketSize - participants.length);
      if(byes < 0) byes = 0;

      const formatLabel = formatLabelFromSettings();
      const bestOf      = settings.bestOf || 1;
      const playerCount = participants.length;

      // Stage ranges (recomputed from settings)
      const stagesRaw = Array.isArray(settings.stages) ? settings.stages : [];
      const stageMeta = computeStageRoundMeta(bracketSize, stagesRaw);
      state.stageRanges = stageMeta.stageRanges || [];

      bracketTitleEl.textContent = settings.name || 'Tournament Bracket';

      // Meta line
      let metaPieces = [
        `Format: ${formatLabel}`,
        `Best of ${bestOf}`,
        `Players: ${playerCount}`
      ];
      if(settings.format === 'single' || settings.format === 'double' || !settings.format){
        metaPieces.push(`Round of ${bracketSize}`);
        metaPieces.push(`Byes: ${byes}`);
      }
      bracketMetaEl.textContent = metaPieces.join(' • ');

      // Render rounds
      bracketContainer.innerHTML = '';

      rounds.forEach((roundMatches, idx) => {
        const roundNumber = idx + 1;
        const col = document.createElement('div');
        col.className = 'round-col';

        const title = document.createElement('div');
        title.className = 'round-title';

        const matchesCount = roundMatches.length;
        const matchesLabel = matchesCount === 1
          ? '1 match'
          : `${matchesCount} matches`;

        const stageInfo = getStageForRound(state.stageRanges, roundNumber);
        if(stageInfo){
          const originalStage = stagesRaw[stageInfo.index];
          const stageName = (originalStage && originalStage.name) || stageInfo.name || ('Stage ' + (stageInfo.index+1));
          const tags = [stageName];

          if(stageInfo.startRound === roundNumber){
            tags.push('start');
          }
          if(stageInfo.endRound === roundNumber){
            const targetLabel = stageInfo.targetPlayers === 1
              ? 'end → champion'
              : `end → top ${stageInfo.targetPlayers}`;
            tags.push(targetLabel);
          }

          title.textContent = `Round ${roundNumber} (${matchesLabel}) • ${tags.join(' | ')}`;
        }else{
          title.textContent = `Round ${roundNumber} (${matchesLabel})`;
        }

        col.appendChild(title);

        roundMatches.forEach(m => {
          const card = document.createElement('div');
          card.className = 'match-card';
          card.dataset.matchId = m.id;

          const metaRow = document.createElement('div');
          metaRow.className = 'match-meta';
          metaRow.innerHTML = `<span>${String(m.id || '').toUpperCase()}</span><span class="badge">Bo${bestOf}</span>`;
          card.appendChild(metaRow);

          const row1 = createPlayerRow(m, 1);
          const row2 = createPlayerRow(m, 2);
          card.appendChild(row1);
          card.appendChild(row2);

          const status = document.createElement('div');
          status.className = 'match-status';

          const p1IsBye = m.p1 && m.p1.isBye;
          const p2IsBye = m.p2 && m.p2.isBye;
          const pureBye = p1IsBye && p2IsBye;

          if(m.winnerId){
            const winner = findParticipantById(m.winnerId) || m.p1 || m.p2;
            status.innerHTML = `<span class="winner-tag">Winner:</span> ${winner ? winner.name : '—'}`;
          }else if(pureBye){
            status.innerHTML = `<span class="pending">Unused BYE slot</span>`;
          }else{
            status.innerHTML = `<span class="pending">Pending result…</span>`;
          }

          card.appendChild(status);
          col.appendChild(card);
        });

        bracketContainer.appendChild(col);
      });
    }

    function createPlayerRow(match, slot){
      const row = document.createElement('div');
      row.className = 'player-row';

      const p = slot === 1 ? match.p1 : match.p2;
      let seedNumber = '—';

      if(p && !p.isBye){
        const seedIdx = state.participants.findIndex(pp => pp.id === p.id);
        if(seedIdx !== -1) seedNumber = seedIdx + 1;
      }

      const seedSpan = document.createElement('span');
      seedSpan.className = 'seed';
      seedSpan.textContent = seedNumber;

      const nameSpan = document.createElement('span');
      nameSpan.className = 'name';
      nameSpan.textContent = p ? p.name : 'TBD';

      if(p && p.isBye){
        row.classList.add('bye');
      }

      const scoreSpan = document.createElement('span');
      scoreSpan.className = 'score';
      const score = slot === 1 ? (match.s1 ?? 0) : (match.s2 ?? 0);
      scoreSpan.textContent = score;

      if(match.winnerId && p && !p.isBye && p.id === match.winnerId){
        row.classList.add('winner');
      }

      row.appendChild(seedSpan);
      row.appendChild(nameSpan);
      row.appendChild(scoreSpan);

      return row;
    }

    // ===== Events =====
    refreshBtn.addEventListener('click', () => loadBracket());
    tournamentSelect.addEventListener('change', () => {
      updateUrlFromSelection();
      loadBracket();
    });

    document.addEventListener('DOMContentLoaded', () => {
      loadTournamentList();
    });
  </script>
</body>
</html>
